<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8">
  <title>libusb++: usbpp.h Source File (libusb++)</title>
  <link href="doxygen.css" rel="stylesheet" type="text/css">
</head>
<div class="header">
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td rowspan="2" width="92">
<a href="../../index.html" title="The API documentation main page"></a>
</td>
<td width="95%">
<h1>libusb++ API Documentation</h1>
</td>
</tr>
<tr>
<td valign="bottom">
<table class="links" border=0 cellspacing=0>
<tr>
<td><a href="index.html">Overview</a></td>
<td><a href="hierarchy.html" title="Inheritance list, sorted roughly  alphabetically">Class&nbsp;Hierarchy</a></td>
<td><a href="classes.html" title="Alphabetical list of classes">Classes</a></td>
<td><a href="annotated.html" title="Classes, structs, unions and interfaces with brief descriptions">Classes&nbsp;(annotated)</a></td>
<td><a href="functions.html" title="Documented class members with links to the classes they belong to">Members</a></td>
<td><a href="namespaces.html" title="All documented namespaces with brief descriptions">Namespaces</a></td>
<td><a href="files.html" title="A list of all documented files with brief descriptions">Source&nbsp;Files</a></td>
</tr>
</table>
</td></tr></table>
</div>
<div id="hgrad"></div>
<div class="text">
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="classes.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
<h1>usbpp.h</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">// -*- C++;indent-tabs-mode: t; tab-width: 4; c-basic-offset: 4; -*-</span>
<a name="l00002"></a>00002 <span class="preprocessor">#ifndef __USBPP_HEADER__</span>
<a name="l00003"></a>00003 <span class="preprocessor"></span><span class="preprocessor">#define __USBPP_HEADER__</span>
<a name="l00004"></a>00004 <span class="preprocessor"></span>
<a name="l00005"></a>00005 <span class="preprocessor">#include &lt;string&gt;</span>
<a name="l00006"></a>00006 <span class="preprocessor">#include &lt;list&gt;</span>
<a name="l00007"></a>00007 
<a name="l00008"></a>00008 <span class="preprocessor">#include &lt;usb.h&gt;</span>
<a name="l00009"></a>00009 
<a name="l00010"></a>00010 <span class="comment">/*</span>
<a name="l00011"></a>00011 <span class="comment"> * The following usb.h function is not wrapped yet:</span>
<a name="l00012"></a>00012 <span class="comment"> *  char *usb_strerror(void);</span>
<a name="l00013"></a>00013 <span class="comment"> */</span>
<a name="l00014"></a>00014 
<a name="l00015"></a>00015 
<a name="l00025"></a>00025 <span class="keyword">namespace </span>USB {
<a name="l00026"></a>00026 
<a name="l00027"></a>00027     <span class="keyword">class </span>Device;
<a name="l00028"></a>00028 
<a name="l00036"></a><a class="code" href="classUSB_1_1Endpoint.html">00036</a>     <span class="keyword">class </span><a class="code" href="classUSB_1_1Endpoint.html" title="Class representing a device endpoint.">Endpoint</a> {
<a name="l00041"></a><a class="code" href="classUSB_1_1Endpoint.html#47a22d51a7d1011c0f014d63fce66428">00041</a>         <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classUSB_1_1Busses.html" title="Class representing all the busses on the machine.">Busses</a>;
<a name="l00042"></a>00042     <span class="keyword">public</span>:
<a name="l00043"></a>00043         <a class="code" href="classUSB_1_1Endpoint.html" title="Class representing a device endpoint.">Endpoint</a>() {};
<a name="l00044"></a>00044 
<a name="l00045"></a>00045 <span class="preprocessor">#ifdef USE_UNTESTED_LIBUSBPP_METHODS</span>
<a name="l00046"></a>00046 <span class="preprocessor"></span>
<a name="l00057"></a>00057         <span class="keywordtype">int</span> bulkWrite(QByteArray message, <span class="keywordtype">int</span> timeout = 100);
<a name="l00058"></a>00058         
<a name="l00071"></a>00071         <span class="keywordtype">int</span> bulkRead(<span class="keywordtype">int</span> length, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *message, <span class="keywordtype">int</span> timeout = 100);
<a name="l00072"></a>00072 
<a name="l00078"></a>00078         <span class="keywordtype">int</span> reset(<span class="keywordtype">void</span>);
<a name="l00079"></a>00079 
<a name="l00085"></a>00085         <span class="keywordtype">int</span> clearHalt(<span class="keywordtype">void</span>);
<a name="l00086"></a>00086 
<a name="l00087"></a>00087 <span class="preprocessor">#endif </span><span class="comment">/* USE_UNTESTED_LIBUSBPP_METHODS */</span>
<a name="l00088"></a>00088 
<a name="l00097"></a>00097         <span class="keywordtype">void</span> <a class="code" href="classUSB_1_1Endpoint.html#10d2aaddabed0b79748df49ffbe0ce5a" title="Endpoint descriptor information output.">dumpDescriptor</a>(<span class="keywordtype">void</span>);
<a name="l00098"></a>00098 
<a name="l00099"></a>00099     <span class="keyword">private</span>:
<a name="l00100"></a>00100         <span class="keywordtype">void</span> setDescriptor(<span class="keyword">struct</span> usb_endpoint_descriptor);
<a name="l00101"></a>00101         <span class="keywordtype">void</span> setParent(<a class="code" href="classUSB_1_1Device.html" title="Class representing a Device on the Bus.">Device</a> *parent);
<a name="l00102"></a>00102         u_int8_t  m_Length;
<a name="l00103"></a>00103         u_int8_t  m_DescriptorType;
<a name="l00104"></a>00104         u_int8_t  m_EndpointAddress;
<a name="l00105"></a>00105         u_int8_t  m_Attributes;
<a name="l00106"></a>00106         u_int16_t m_MaxPacketSize;
<a name="l00107"></a>00107         u_int8_t  m_Interval;
<a name="l00108"></a>00108         u_int8_t  m_Refresh;
<a name="l00109"></a>00109         u_int8_t  m_SynchAddress;
<a name="l00110"></a>00110         <a class="code" href="classUSB_1_1Device.html" title="Class representing a Device on the Bus.">Device</a>    *m_parent;
<a name="l00111"></a>00111     };
<a name="l00112"></a>00112 
<a name="l00113"></a>00113     <span class="keyword">class </span>AltSetting : <span class="keyword">public</span> std::list&lt;Endpoint *&gt; {
<a name="l00118"></a>00118         <span class="keyword">friend</span> <span class="keyword">class </span>Busses;
<a name="l00119"></a>00119     <span class="keyword">public</span>:
<a name="l00120"></a>00120         AltSetting() {};
<a name="l00121"></a>00121         u_int8_t numEndpoints(<span class="keywordtype">void</span>);
<a name="l00122"></a>00122 
<a name="l00131"></a>00131         <span class="keywordtype">void</span> dumpDescriptor(<span class="keywordtype">void</span>);
<a name="l00132"></a>00132 
<a name="l00133"></a>00133         Endpoint *firstEndpoint(<span class="keywordtype">void</span>);
<a name="l00134"></a>00134         Endpoint *nextEndpoint(<span class="keywordtype">void</span>);
<a name="l00135"></a>00135         Endpoint *lastEndpoint(<span class="keywordtype">void</span>);
<a name="l00136"></a>00136 
<a name="l00137"></a>00137     <span class="keyword">private</span>:
<a name="l00138"></a>00138         std::list&lt;Endpoint *&gt;::const_iterator iter;
<a name="l00139"></a>00139 
<a name="l00140"></a>00140         <span class="keywordtype">void</span> setDescriptor(<span class="keyword">struct</span> usb_interface_descriptor);
<a name="l00141"></a>00141         <span class="comment">/* we don't use a normal usb_interface_descriptor */</span>
<a name="l00142"></a>00142         <span class="comment">/* because that would bring in the endpoint list */</span>
<a name="l00143"></a>00143         u_int8_t m_Length;
<a name="l00144"></a>00144         u_int8_t m_DescriptorType;
<a name="l00145"></a>00145         u_int8_t m_InterfaceNumber;
<a name="l00146"></a>00146         u_int8_t m_AlternateSetting;
<a name="l00147"></a>00147         u_int8_t m_NumEndpoints;
<a name="l00148"></a>00148         u_int8_t m_InterfaceClass;
<a name="l00149"></a>00149         u_int8_t m_InterfaceSubClass;
<a name="l00150"></a>00150         u_int8_t m_InterfaceProtocol;
<a name="l00151"></a>00151         u_int8_t m_Interface;
<a name="l00152"></a>00152     };
<a name="l00153"></a>00153 
<a name="l00165"></a><a class="code" href="classUSB_1_1Interface.html">00165</a>     <span class="keyword">class </span><a class="code" href="classUSB_1_1Interface.html" title="Class representing an interface of a Device.">Interface</a> : <span class="keyword">public</span> std::list&lt;AltSetting *&gt; {
<a name="l00170"></a><a class="code" href="classUSB_1_1Interface.html#47a22d51a7d1011c0f014d63fce66428">00170</a>         <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classUSB_1_1Busses.html" title="Class representing all the busses on the machine.">Busses</a>;
<a name="l00171"></a>00171     <span class="keyword">public</span>:
<a name="l00172"></a>00172         <a class="code" href="classUSB_1_1Interface.html" title="Class representing an interface of a Device.">Interface</a>() {};
<a name="l00173"></a>00173 
<a name="l00174"></a>00174 <span class="preprocessor">#ifdef LIBUSB_HAS_GET_DRIVER_NP</span>
<a name="l00175"></a>00175 <span class="preprocessor"></span>
<a name="l00184"></a>00184         <span class="keywordtype">int</span> <a class="code" href="classUSB_1_1Interface.html#78bab9ef486b1b7fd25b678dde62ed76" title="get the current driver for an interface">driverName</a>(std::string &amp;driver);
<a name="l00185"></a>00185 <span class="preprocessor">#endif</span>
<a name="l00186"></a>00186 <span class="preprocessor"></span>
<a name="l00187"></a>00187 <span class="preprocessor">#ifdef USE_UNTESTED_LIBUSBPP_METHODS</span>
<a name="l00188"></a>00188 <span class="preprocessor"></span>
<a name="l00197"></a>00197         <span class="keywordtype">int</span> claim(<span class="keywordtype">void</span>);
<a name="l00198"></a>00198 
<a name="l00208"></a>00208         <span class="keywordtype">int</span> release(<span class="keywordtype">void</span>);
<a name="l00209"></a>00209 
<a name="l00220"></a>00220         <span class="keywordtype">int</span> setAltSetting(<span class="keywordtype">int</span> altSettingNumber);
<a name="l00221"></a>00221 <span class="preprocessor">#endif </span><span class="comment">/* USE_UNTESTED_LIBUSBPP_METHODS */</span>
<a name="l00222"></a>00222 
<a name="l00229"></a>00229         u_int8_t <a class="code" href="classUSB_1_1Interface.html#dd1fe18a04d0b87b91bd5d3a18d93874" title="Number of Alternative Settings that this interface has.">numAltSettings</a>(<span class="keywordtype">void</span>);
<a name="l00230"></a>00230 
<a name="l00242"></a>00242         AltSetting *<a class="code" href="classUSB_1_1Interface.html#a22dee97c77f3ec6d569c5102e7b47d1" title="First AltSetting for the Interface.">firstAltSetting</a>(<span class="keywordtype">void</span>);
<a name="l00243"></a>00243 
<a name="l00274"></a>00274         AltSetting *<a class="code" href="classUSB_1_1Interface.html#d1549afbbc9d95a6d131a1e6ff3bbd37" title="Next AltSetting for the Interface.">nextAltSetting</a>(<span class="keywordtype">void</span>);
<a name="l00275"></a>00275 
<a name="l00285"></a>00285         AltSetting *<a class="code" href="classUSB_1_1Interface.html#6eab25a15d916a0a6602d440bbc232cd" title="Last AltSetting for the Interface.">lastAltSetting</a>(<span class="keywordtype">void</span>);
<a name="l00286"></a>00286 
<a name="l00287"></a>00287     <span class="keyword">private</span>:
<a name="l00288"></a>00288         std::list&lt;AltSetting *&gt;::const_iterator iter;
<a name="l00289"></a>00289 
<a name="l00290"></a>00290         <span class="keywordtype">void</span> setNumAltSettings(u_int8_t);
<a name="l00291"></a>00291         <span class="keywordtype">void</span> setParent(<a class="code" href="classUSB_1_1Device.html" title="Class representing a Device on the Bus.">Device</a> *parent);
<a name="l00292"></a>00292         u_int8_t m_numAltSettings;
<a name="l00293"></a>00293         <a class="code" href="classUSB_1_1Device.html" title="Class representing a Device on the Bus.">Device</a>    *m_parent;
<a name="l00294"></a>00294 
<a name="l00295"></a>00295         <span class="comment">/* index representing the interface, in this configuration */</span>
<a name="l00296"></a>00296         <span class="keywordtype">int</span> m_interfaceNumber;
<a name="l00297"></a>00297         <span class="keywordtype">void</span> setInterfaceNumber(<span class="keywordtype">int</span> interfaceNumber);
<a name="l00298"></a>00298     };
<a name="l00299"></a>00299 
<a name="l00308"></a><a class="code" href="classUSB_1_1Configuration.html">00308</a>     <span class="keyword">class </span><a class="code" href="classUSB_1_1Configuration.html" title="Class representing a configuration of a Device.">Configuration</a> : <span class="keyword">public</span> std::list&lt;Interface *&gt; {
<a name="l00313"></a><a class="code" href="classUSB_1_1Configuration.html#47a22d51a7d1011c0f014d63fce66428">00313</a>         <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classUSB_1_1Busses.html" title="Class representing all the busses on the machine.">Busses</a>;
<a name="l00314"></a>00314     <span class="keyword">public</span>:
<a name="l00315"></a>00315         <a class="code" href="classUSB_1_1Configuration.html" title="Class representing a configuration of a Device.">Configuration</a>() {};
<a name="l00316"></a>00316 
<a name="l00325"></a>00325         <span class="keywordtype">void</span> <a class="code" href="classUSB_1_1Configuration.html#05ee4c741e8d7576183e84a5ca22a2af" title="Configuration descriptor information output.">dumpDescriptor</a>(<span class="keywordtype">void</span>);
<a name="l00326"></a>00326 
<a name="l00333"></a>00333         u_int8_t <a class="code" href="classUSB_1_1Configuration.html#752360a0462dd0743b68f9a757372df5" title="Number of Interfaces that this device has.">numInterfaces</a>(<span class="keywordtype">void</span>);
<a name="l00334"></a>00334 
<a name="l00346"></a>00346         <a class="code" href="classUSB_1_1Interface.html" title="Class representing an interface of a Device.">Interface</a> *<a class="code" href="classUSB_1_1Configuration.html#5e3e79dd26edb8e1b7ff947911810305" title="First Interface for the Configuration.">firstInterface</a>(<span class="keywordtype">void</span>);
<a name="l00347"></a>00347 
<a name="l00371"></a>00371         <a class="code" href="classUSB_1_1Interface.html" title="Class representing an interface of a Device.">Interface</a> *<a class="code" href="classUSB_1_1Configuration.html#33993bcdb45777e438c9bc12aea095f4" title="Next Interface for the Configuration.">nextInterface</a>(<span class="keywordtype">void</span>);
<a name="l00372"></a>00372 
<a name="l00381"></a>00381         <a class="code" href="classUSB_1_1Interface.html" title="Class representing an interface of a Device.">Interface</a> *<a class="code" href="classUSB_1_1Configuration.html#f2a353fa9b0d5d60de2faf3b8012a7be" title="Last Interface for the Configuration.">lastInterface</a>(<span class="keywordtype">void</span>);
<a name="l00382"></a>00382 
<a name="l00383"></a>00383     <span class="keyword">private</span>:
<a name="l00384"></a>00384         std::list&lt;Interface *&gt;::const_iterator iter;
<a name="l00385"></a>00385 
<a name="l00386"></a>00386         <span class="keywordtype">void</span> setDescriptor(<span class="keyword">struct</span> usb_config_descriptor);
<a name="l00387"></a>00387         <span class="comment">/* we don't use a normal usb_config_descriptor */</span>
<a name="l00388"></a>00388         <span class="comment">/* because that would bring in the interface list */</span>
<a name="l00389"></a>00389         u_int8_t  m_Length;
<a name="l00390"></a>00390         u_int8_t  m_DescriptorType;
<a name="l00391"></a>00391         u_int16_t m_TotalLength;
<a name="l00392"></a>00392         u_int8_t  m_NumInterfaces;
<a name="l00393"></a>00393         u_int8_t  m_ConfigurationValue;
<a name="l00394"></a>00394         u_int8_t  m_Configuration;
<a name="l00395"></a>00395         u_int8_t  m_Attributes;
<a name="l00396"></a>00396         u_int8_t  m_MaxPower; 
<a name="l00397"></a>00397     };
<a name="l00398"></a>00398 
<a name="l00407"></a><a class="code" href="classUSB_1_1Device.html">00407</a>     <span class="keyword">class </span><a class="code" href="classUSB_1_1Device.html" title="Class representing a Device on the Bus.">Device</a> : <span class="keyword">public</span> std::list&lt;Configuration *&gt; {
<a name="l00412"></a><a class="code" href="classUSB_1_1Device.html#47a22d51a7d1011c0f014d63fce66428">00412</a>         <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classUSB_1_1Busses.html" title="Class representing all the busses on the machine.">Busses</a>;
<a name="l00417"></a><a class="code" href="classUSB_1_1Device.html#b2d499aedae98d5bb86006432c06888f">00417</a>         <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classUSB_1_1Interface.html" title="Class representing an interface of a Device.">Interface</a>;
<a name="l00422"></a><a class="code" href="classUSB_1_1Device.html#500d74fc41e3ab6b4889a579193566ed">00422</a>         <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classUSB_1_1Endpoint.html" title="Class representing a device endpoint.">Endpoint</a>;
<a name="l00423"></a>00423 
<a name="l00424"></a>00424     <span class="keyword">public</span>:
<a name="l00425"></a>00425         <a class="code" href="classUSB_1_1Device.html" title="Class representing a Device on the Bus.">Device</a>() {};
<a name="l00426"></a>00426         ~<a class="code" href="classUSB_1_1Device.html" title="Class representing a Device on the Bus.">Device</a>();
<a name="l00427"></a>00427 
<a name="l00443"></a>00443         std::string <a class="code" href="classUSB_1_1Device.html#40707cfc0336bcafe5d4d2d4680102c3" title="OS representation of filename for this device.">fileName</a>(<span class="keywordtype">void</span>);
<a name="l00444"></a>00444 
<a name="l00456"></a>00456         u_int16_t <a class="code" href="classUSB_1_1Device.html#39085326bda4e77c2a718e9506f0a596" title="The vendor ID number, as provided by the device.">idVendor</a>(<span class="keywordtype">void</span>);
<a name="l00457"></a>00457 
<a name="l00467"></a>00467         u_int16_t <a class="code" href="classUSB_1_1Device.html#1533397ccbc3dae3396c32621ccad828" title="The product ID number, as provided by the device.">idProduct</a>(<span class="keywordtype">void</span>);
<a name="l00468"></a>00468 
<a name="l00478"></a>00478         u_int16_t <a class="code" href="classUSB_1_1Device.html#0d506b1a92c3e4c66b77c2169b41c65c" title="The product&amp;#39;s revision ID, as provided by the device.">idRevision</a>(<span class="keywordtype">void</span>);
<a name="l00479"></a>00479 
<a name="l00496"></a>00496         u_int8_t <a class="code" href="classUSB_1_1Device.html#d5f8bcb16bcfeeff4f6cfb94f3e86f5c" title="The device&amp;#39;s USB class, as provided by the device.">devClass</a>(<span class="keywordtype">void</span>);
<a name="l00497"></a>00497 
<a name="l00505"></a>00505         u_int8_t <a class="code" href="classUSB_1_1Device.html#fd89acfaedf6ef600d5ae2cd8a28a729" title="The device&amp;#39;s USB subclass, as provided by the device.">devSubClass</a>(<span class="keywordtype">void</span>);
<a name="l00506"></a>00506 
<a name="l00515"></a>00515         u_int8_t <a class="code" href="classUSB_1_1Device.html#a8b88b226b45a4e92b450dbe5cdb2548" title="The device&amp;#39;s USB protocol, as provided by the device.">devProtocol</a>(<span class="keywordtype">void</span>);
<a name="l00516"></a>00516 
<a name="l00517"></a>00517     
<a name="l00531"></a>00531         std::string <a class="code" href="classUSB_1_1Device.html#87490b169d94314a316e09be7d8e810b" title="The vendor name string, as provided by the device.">Vendor</a>(<span class="keywordtype">void</span>);
<a name="l00532"></a>00532 
<a name="l00546"></a>00546         std::string <a class="code" href="classUSB_1_1Device.html#a7bca20180b3792a78f233bfee8a1a02" title="The product name string, as provided by the device.">Product</a>(<span class="keywordtype">void</span>);
<a name="l00547"></a>00547 
<a name="l00561"></a>00561         std::string <a class="code" href="classUSB_1_1Device.html#ea04f02ea078054f8d8eea2d13e96b53" title="The serial number string, as provided by the device.">SerialNumber</a>(<span class="keywordtype">void</span>);
<a name="l00562"></a>00562 
<a name="l00569"></a>00569         u_int8_t <a class="code" href="classUSB_1_1Device.html#ba66517ee4e77019284cee380a21007a" title="Number of Configurations that this device has.">numConfigurations</a>(<span class="keywordtype">void</span>);
<a name="l00570"></a>00570 
<a name="l00582"></a>00582         <span class="keywordtype">int</span> <a class="code" href="classUSB_1_1Device.html#2b20b0f4694ecb5f1f26825ca088e77d" title="fetch an arbitrary string from the device">string</a>(std::string &amp;buf, <span class="keywordtype">int</span> index, u_int16_t lang=0);
<a name="l00583"></a>00583 
<a name="l00593"></a>00593         <a class="code" href="classUSB_1_1Configuration.html" title="Class representing a configuration of a Device.">Configuration</a> *<a class="code" href="classUSB_1_1Device.html#33d96b90b7a5d67c2bf5e9c81dcc3126" title="First Configuration for the Device.">firstConfiguration</a>(<span class="keywordtype">void</span>);
<a name="l00594"></a>00594 
<a name="l00612"></a>00612         <a class="code" href="classUSB_1_1Configuration.html" title="Class representing a configuration of a Device.">Configuration</a> *<a class="code" href="classUSB_1_1Device.html#d26ead62f79033a13ea595a71993f8a6" title="Next Configuration for the Device.">nextConfiguration</a>(<span class="keywordtype">void</span>);
<a name="l00613"></a>00613 
<a name="l00621"></a>00621         <a class="code" href="classUSB_1_1Configuration.html" title="Class representing a configuration of a Device.">Configuration</a> *<a class="code" href="classUSB_1_1Device.html#ab4986ad307832cb33ba6274eaf0a0da" title="Last Configuration for the Device.">lastConfiguration</a>(<span class="keywordtype">void</span>);
<a name="l00622"></a>00622 
<a name="l00644"></a>00644         <span class="keywordtype">int</span> <a class="code" href="classUSB_1_1Device.html#fb947f88287c8fed91740c17b29d060c" title="USB control transfer.">controlTransfer</a>(u_int8_t requestType, u_int8_t request,
<a name="l00645"></a>00645                     u_int16_t value, u_int16_t index, u_int16_t length,
<a name="l00646"></a>00646                     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *payload,
<a name="l00647"></a>00647                     <span class="keywordtype">int</span> timeout = 100); 
<a name="l00648"></a>00648 
<a name="l00649"></a>00649 <span class="preprocessor">#ifdef USE_UNTESTED_LIBUSBPP_METHODS</span>
<a name="l00650"></a>00650 <span class="preprocessor"></span>
<a name="l00658"></a>00658         <span class="keywordtype">int</span> reset(<span class="keywordtype">void</span>);
<a name="l00659"></a>00659 
<a name="l00670"></a>00670         <span class="keywordtype">int</span> setConfiguration(<span class="keywordtype">int</span> configurationNumber);
<a name="l00671"></a>00671 <span class="preprocessor">#endif </span><span class="comment">/* USE_UNTESTED_LIBUSBPP_METHODS */</span>
<a name="l00672"></a>00672     
<a name="l00673"></a>00673     <span class="keyword">private</span>:
<a name="l00674"></a>00674         std::list&lt;Configuration *&gt;::const_iterator iter;
<a name="l00675"></a>00675 
<a name="l00676"></a>00676         <span class="keyword">struct </span>usb_dev_handle *handle();
<a name="l00677"></a>00677         <span class="keywordtype">void</span> setFileName(std::string);
<a name="l00678"></a>00678         <span class="keywordtype">void</span> setDescriptor(<span class="keyword">struct</span> usb_device_descriptor);
<a name="l00679"></a>00679         <span class="keywordtype">void</span> setVendor(std::string);
<a name="l00680"></a>00680         <span class="keywordtype">void</span> setProduct(std::string);
<a name="l00681"></a>00681         <span class="keywordtype">void</span> setSerialNumber(std::string);
<a name="l00682"></a>00682         <span class="keywordtype">void</span> setDevHandle(<span class="keyword">struct</span> usb_dev_handle *);
<a name="l00683"></a>00683         std::string m_fileName;
<a name="l00684"></a>00684         std::string m_Vendor;
<a name="l00685"></a>00685         std::string m_Product;
<a name="l00686"></a>00686         std::string m_SerialNumber;
<a name="l00687"></a>00687         <span class="keyword">struct </span>usb_device *m_dev;
<a name="l00688"></a>00688         <span class="keyword">struct </span>usb_dev_handle *m_handle;
<a name="l00689"></a>00689         <span class="keyword">struct </span>usb_device_descriptor m_descriptor;
<a name="l00690"></a>00690     };
<a name="l00691"></a>00691 
<a name="l00697"></a><a class="code" href="classUSB_1_1Bus.html">00697</a>     <span class="keyword">class </span><a class="code" href="classUSB_1_1Bus.html" title="Class representing a single bus on the machine.">Bus</a> : <span class="keyword">public</span> std::list&lt;Device *&gt; {
<a name="l00702"></a><a class="code" href="classUSB_1_1Bus.html#47a22d51a7d1011c0f014d63fce66428">00702</a>         <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classUSB_1_1Busses.html" title="Class representing all the busses on the machine.">Busses</a>;
<a name="l00703"></a>00703     <span class="keyword">public</span>:
<a name="l00704"></a>00704         <a class="code" href="classUSB_1_1Bus.html" title="Class representing a single bus on the machine.">Bus</a>() {};
<a name="l00719"></a>00719         std::string <a class="code" href="classUSB_1_1Bus.html#40eb05607742949ea288079f344a1bf9" title="OS representation of directory name for this Bus.">directoryName</a>(<span class="keywordtype">void</span>);
<a name="l00720"></a>00720     <span class="keyword">private</span>:
<a name="l00721"></a>00721         std::list&lt;Device *&gt;::const_iterator iter;
<a name="l00722"></a>00722 
<a name="l00723"></a>00723         <span class="keywordtype">void</span> setDirectoryName(std::string);
<a name="l00724"></a>00724         std::string m_directoryName;
<a name="l00725"></a>00725     };
<a name="l00726"></a>00726 
<a name="l00741"></a><a class="code" href="classUSB_1_1DeviceID.html">00741</a>     <span class="keyword">class </span><a class="code" href="classUSB_1_1DeviceID.html" title="A vendor/product ID pair.">DeviceID</a> {
<a name="l00742"></a>00742     <span class="keyword">public</span>:
<a name="l00743"></a>00743         <a class="code" href="classUSB_1_1DeviceID.html" title="A vendor/product ID pair.">DeviceID</a>() {};
<a name="l00753"></a>00753         <a class="code" href="classUSB_1_1DeviceID.html" title="A vendor/product ID pair.">DeviceID</a>(u_int16_t <a class="code" href="classUSB_1_1DeviceID.html#bc65be5bcdfcea0fc7b2dac025c8d18c" title="vendor number for the device">vendor</a>, u_int16_t <a class="code" href="classUSB_1_1DeviceID.html#d8965d52590fe1cca9ba0c3331b8bfa5" title="product number for the device">product</a>);
<a name="l00754"></a>00754 
<a name="l00760"></a>00760         u_int16_t <a class="code" href="classUSB_1_1DeviceID.html#bc65be5bcdfcea0fc7b2dac025c8d18c" title="vendor number for the device">vendor</a>(<span class="keywordtype">void</span>);
<a name="l00761"></a>00761 
<a name="l00767"></a>00767         u_int16_t <a class="code" href="classUSB_1_1DeviceID.html#d8965d52590fe1cca9ba0c3331b8bfa5" title="product number for the device">product</a>(<span class="keywordtype">void</span>);
<a name="l00768"></a>00768 
<a name="l00769"></a>00769     <span class="keyword">private</span>:
<a name="l00770"></a>00770         u_int16_t m_vendor;
<a name="l00771"></a>00771         u_int16_t m_product;
<a name="l00772"></a>00772     };
<a name="l00773"></a>00773 
<a name="l00782"></a><a class="code" href="namespaceUSB.html#eecb8ff67522c5a0c654156c8eda52e9">00782</a>     <span class="keyword">typedef</span> std::list&lt;DeviceID&gt; <a class="code" href="namespaceUSB.html#eecb8ff67522c5a0c654156c8eda52e9" title="A list of vendor/product pairs.">DeviceIDList</a>;
<a name="l00783"></a>00783 
<a name="l00789"></a><a class="code" href="classUSB_1_1Busses.html">00789</a>     <span class="keyword">class </span><a class="code" href="classUSB_1_1Busses.html" title="Class representing all the busses on the machine.">Busses</a> : <span class="keyword">public</span> std::list&lt;Bus *&gt; {
<a name="l00790"></a>00790     <span class="keyword">public</span>:
<a name="l00791"></a>00791         <a class="code" href="classUSB_1_1Busses.html" title="Class representing all the busses on the machine.">Busses</a>();
<a name="l00792"></a>00792 
<a name="l00803"></a>00803         <span class="keywordtype">void</span> <a class="code" href="classUSB_1_1Busses.html#b9bf919e823340606a094d6023d1fd44" title="Update method.">rescan</a>(<span class="keywordtype">void</span>);
<a name="l00804"></a>00804 
<a name="l00812"></a>00812         std::list&lt;Device *&gt; <a class="code" href="classUSB_1_1Busses.html#d7ff666358b659e3904f17bfd1765a60" title="find all devices with matching device class designator">match</a>(u_int8_t Class);
<a name="l00813"></a>00813 
<a name="l00842"></a>00842         std::list&lt;Device *&gt; <a class="code" href="classUSB_1_1Busses.html#d7ff666358b659e3904f17bfd1765a60" title="find all devices with matching device class designator">match</a>(<a class="code" href="namespaceUSB.html#eecb8ff67522c5a0c654156c8eda52e9" title="A list of vendor/product pairs.">DeviceIDList</a>);
<a name="l00843"></a>00843 
<a name="l00844"></a>00844     <span class="keyword">private</span>:
<a name="l00845"></a>00845         std::list&lt;Bus *&gt;::const_iterator iter;
<a name="l00846"></a>00846     };
<a name="l00847"></a>00847   
<a name="l00848"></a>00848     <span class="keyword">class </span>Error {
<a name="l00849"></a>00849     <span class="keyword">public</span>:
<a name="l00850"></a>00850     <span class="keyword">private</span>:
<a name="l00851"></a>00851     };
<a name="l00852"></a>00852 
<a name="l00853"></a>00853 }
<a name="l00854"></a>00854 <span class="preprocessor">#endif </span><span class="comment">/* __USBPP_HEADER__ */</span>
<a name="l00855"></a>00855 
</pre></div></div>
</div>
<div class="bottom">
This file is part of the documentation for libusb++ .
</div>
<div class="bottom" style="color:#cccccc">
Documentation copyright &copy; 2004 Brad Hards.<br>
Generated on Fri Jul 2 09:59:25 2010 by
<a href="http://www.doxygen.org/index.html">doxygen</a> 1.5.5 written by <a href="mailto:dimitri@stack.nl">Dimitri van Heesch</a>.
</div>
</body>
</html>
