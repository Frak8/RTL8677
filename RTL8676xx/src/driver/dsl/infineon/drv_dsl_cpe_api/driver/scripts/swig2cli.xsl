<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:fo="http://www.w3.org/1999/XSL/Format">
	<xsl:output method="text" indent="yes" encoding="UTF-8"/>
	<xsl:template match="/">
		<xsl:text>/* attention, this file was automatically generated by swig and swig2cli.xsl */

#define DSL_INTERN

#include "drv_dsl_cpe_api.h"

#ifdef INCLUDE_DSL_API_CLI

/* for debugging: */
#ifdef DSL_CLI_LOCAL
#undef DSL_CLI_LOCAL
#endif
#if 0
#define DSL_CLI_LOCAL
#else
#define DSL_CLI_LOCAL static
#endif

	DSL_Error_t CLI_DSL_CheckHelp(const DSL_char_t *pCommands, const DSL_char_t *pUsage, DSL_char_t *sOut, DSL_size_t nOutSz)
	{
		if ( pCommands &amp;&amp; ( strstr ( pCommands, "-h" ) || strstr ( pCommands, "--help" ) || strstr ( pCommands, "/h" ) || strstr ( pCommands, "-?" ) ) )
		{
		   DSL_snprintf (sOut, nOutSz, pUsage );
		   return DSL_ERROR;
	     }
		return DSL_SUCCESS;
	}

	DSL_void_t CLI_DSL_GetDeviceRange(DSL_uint16_t nDevice, DSL_uint16_t *nStart, DSL_uint16_t *nEnd)
	{
	   if ( nDevice == ( DSL_uint16_t ) - 1 )
	   {
	      *nStart = 0;
	      *nEnd = DSL_MAX_DEVICE_INSTANCES;
	   }
	   else
	   {
	      *nStart = nDevice;
	      *nEnd = nDevice + 1;
	   }
	}
	</xsl:text>
		<xsl:choose>
			<xsl:when test="1=1">
				<xsl:for-each select="//cdecl[attributelist/attribute/@name='decl']">
					<xsl:sort select="attributelist/attribute[@name='name']/@value" data-type="text" order="ascending"/>
					<xsl:apply-templates select="." mode="definition"/>
				</xsl:for-each>
				<xsl:text>&#13;DSL_void_t DSL_CLI_AutogenRegister(DSL_void_t) { </xsl:text>
					<xsl:for-each select="//cdecl[attributelist/attribute/@name='decl']">
						<xsl:sort select="attributelist/attribute[@name='name']/@value" data-type="text" order="ascending"/>
							<xsl:apply-templates select="." mode="register"/>
					</xsl:for-each>
				<xsl:text>}	</xsl:text>
			</xsl:when>
			<xsl:otherwise>
				<!-- for fast test use this examples here and exclude below -->			
				<xsl:apply-templates select="//cdecl[attributelist/attribute/@name='decl' and attributelist/attribute/@value='DSL_CE_BCAM_EntryAdd']" mode="definition"/>
<!--
				<xsl:apply-templates select="//cdecl[attributelist/attribute/@name='decl' and attributelist/attribute/@value='DSL_AssignTableCreate']" mode="definition"/>
				<xsl:apply-templates select="//cdecl[attributelist/attribute/@name='decl' and attributelist/attribute/@value='DSL_DCT_Index_Query']" mode="definition"/>
				<xsl:apply-templates select="//cdecl[attributelist/attribute/@name='decl' and attributelist/attribute/@value='DSL_BoundaryScanInfoGet']" mode="definition"/>
				<xsl:apply-templates select="//cdecl[attributelist/attribute/@name='decl' and attributelist/attribute/@value='DSL_CKT_EntryAdd']" mode="definition"/>
				<xsl:apply-templates select="//cdecl[attributelist/attribute/@name='decl' and attributelist/attribute/@value='DSL_CKT_EntryQuery']" mode="definition"/>
				<xsl:apply-templates select="//cdecl[attributelist/attribute/@name='decl' and attributelist/attribute/@value='DSL_Forwarding_FIB_MACDA_EntryQuery']" mode="definition"/>
				<xsl:apply-templates select="//cdecl[attributelist/attribute/@name='decl' and attributelist/attribute/@value='DSL_Forwarding_FIB_MACDA_EntryAdd']" mode="definition"/>
				<xsl:apply-templates select="//cdecl[attributelist/attribute/@name='decl' and attributelist/attribute/@value='DSL_BasicDeviceInit']" mode="definition"/>
				<xsl:apply-templates select="//cdecl[attributelist/attribute/@name='decl' and attributelist/attribute/@value='DSL_EBM_Reset']" mode="definition"/>
-->
			</xsl:otherwise>
		</xsl:choose>
<xsl:text>

#endif /* INCLUDE_DSL_API_CLI */
</xsl:text>
		
	</xsl:template>
	<xsl:template match="cdecl" mode="definition">
		<xsl:variable name="NAME" select="attributelist/attribute[@name='name']/@value"/>
		<xsl:if test="starts-with(attributelist/attribute[@name='decl']/@value,'f')">
			<xsl:message terminate="no">running now: <xsl:value-of select="$NAME"/></xsl:message>
			<xsl:text>
			DSL_CLI_LOCAL DSL_void_t CLI_</xsl:text>
			<xsl:value-of select="$NAME"/>
			<xsl:text>(DSL_devCtx_t *devCtx, DSL_char_t *pCommands, DSL_char_t *sOut, DSL_size_t nOutSz)
			{ </xsl:text>
			<xsl:apply-templates select="." mode="function"/>
			<xsl:text>
			} 
			</xsl:text>
		</xsl:if>
	</xsl:template>
	<xsl:template name="noprefix">
		<xsl:param name="NAME"/>
		<xsl:variable name="NOPREFIX1" select="substring-after($NAME, 'DSL_')"/>
		<xsl:variable name="NOPREFIX2" select="substring-after($NAME, 'DSL_Gxxx_')"/>
		<xsl:choose>
			<xsl:when test="string-length($NOPREFIX2)">
				<xsl:value-of select="$NOPREFIX2"/>
			</xsl:when>
			<xsl:when test="string-length($NOPREFIX1)">
				<xsl:value-of select="$NOPREFIX1"/>
			</xsl:when>
			<xsl:otherwise/>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="shortcmd">
		<xsl:param name="NAME"/>
		<xsl:variable name="UPPER" select="translate($NAME,'abcdefghijklmnopqrstuvwxyz_','')"/>
		<xsl:value-of select="translate($UPPER, 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 'abcdefghijklmnopqrstuvwxyz')"/>
	</xsl:template>
	<xsl:template match="cdecl" mode="register">
		<xsl:variable name="NAME" select="attributelist/attribute[@name='name']/@value"/>
		<xsl:if test="starts-with(attributelist/attribute[@name='decl']/@value,'f')">
			<xsl:variable name="NOPREFIX">
				<xsl:call-template name="noprefix">
					<xsl:with-param name="NAME" select="$NAME"/>
				</xsl:call-template>
			</xsl:variable>
			<xsl:variable name="SHORTCMD">
				<xsl:call-template name="shortcmd">
					<xsl:with-param name="NAME" select="$NOPREFIX"/>
				</xsl:call-template>
			</xsl:variable>
			<xsl:text>
			DSL_CLI_CommandAdd("</xsl:text>
			<xsl:value-of select="$SHORTCMD"/>
			<xsl:text>", "</xsl:text>
			<xsl:value-of select="$NOPREFIX"/>
			<xsl:text>", </xsl:text>
			<xsl:text>CLI_</xsl:text>
			<xsl:value-of select="$NAME"/>
			<xsl:text>);</xsl:text>
		</xsl:if>
	</xsl:template>
	<xsl:template match="cdecl" mode="function">
		<xsl:text>DSL_Error_t ret = 0;</xsl:text>
		<xsl:variable name="NAME" select="attributelist/attribute[@name='name']/@value"/>
		<xsl:variable name="RETURN_TYPE" select="attributelist/attribute[@name='type']/@value"/>
			<xsl:message terminate="no"> declaration</xsl:message>
		<xsl:apply-templates select="attributelist/parmlist/parm[attributelist/attribute[@name='name']/@value!='devCtx']" mode="declaration"/>
		<xsl:variable name="SCAN_1">
			<xsl:message terminate="no"> scan1</xsl:message>
			<xsl:apply-templates select="attributelist/parmlist/parm" mode="scan_1"/>
		</xsl:variable>
		<xsl:variable name="SCAN_2">
			<xsl:message terminate="no"> scan2</xsl:message>
			<xsl:apply-templates select="attributelist/parmlist/parm" mode="scan_2"/>
		</xsl:variable>
		<xsl:variable name="PRINT_RETURNS_1">
			<xsl:message terminate="no"> print1</xsl:message>
			<xsl:apply-templates select="attributelist/parmlist/parm" mode="print_returns_1"/>
		</xsl:variable>
		<xsl:variable name="PRINT_RETURNS_2">
			<xsl:message terminate="no"> print2</xsl:message>
			<xsl:apply-templates select="attributelist/parmlist/parm" mode="print_returns_2"/>
		</xsl:variable>
		<xsl:variable name="SCAN_NUM" select="string-length(translate($SCAN_1,'abcdefghijklmnopqrstuvwxyz_[0123456789] ',''))"/>
		<xsl:variable name="USAGE">
			<xsl:variable name="NOPREFIX">
				<xsl:call-template name="noprefix">
					<xsl:with-param name="NAME" select="$NAME"/>
				</xsl:call-template>
			</xsl:variable>
			<xsl:variable name="SHORTCMD">
				<xsl:call-template name="shortcmd">
					<xsl:with-param name="NAME" select="$NOPREFIX"/>
				</xsl:call-template>
			</xsl:variable>
			<xsl:variable name="INPUT_PAR">
				<xsl:message terminate="no"> help_in</xsl:message>
				<xsl:apply-templates select="attributelist/parmlist/parm" mode="help_in"/>
			</xsl:variable>
			<xsl:variable name="OUTPUT_PAR">
				<xsl:text>"- DSL_Error_t nReturn" DSL_CRLF \
</xsl:text>
				<xsl:message terminate="no"> help_out</xsl:message>
				<xsl:apply-templates select="attributelist/parmlist/parm" mode="help_out"/>
			</xsl:variable>
			<xsl:text>"Long Form: </xsl:text>
			<xsl:value-of select="$NOPREFIX"/>
			<xsl:text>" DSL_CRLF "</xsl:text>
			<xsl:text>Short Form: </xsl:text>
			<xsl:value-of select="$SHORTCMD"/>
			<xsl:text>" DSL_CRLF \
</xsl:text>
			<xsl:if test="$INPUT_PAR!=''">
				<xsl:text>"Input Parameter" DSL_CRLF \
</xsl:text>
				<xsl:value-of select="$INPUT_PAR"/>
				<xsl:text>DSL_CRLF \
</xsl:text>
			</xsl:if>
			<xsl:if test="$OUTPUT_PAR!=''">
				<xsl:text>"Output Parameter" DSL_CRLF \
</xsl:text>
				<xsl:value-of select="$OUTPUT_PAR"/>
				<xsl:text>DSL_CRLF \
</xsl:text>
			</xsl:if>
			<xsl:text>""</xsl:text>
		</xsl:variable>

		<xsl:if test="contains($USAGE,'nDevice')">
			<xsl:text>DSL_uint16_t nStart=0, nEnd=0;</xsl:text>
		</xsl:if>

		<xsl:text>
#ifndef DSL_DEBUG_DISABLE
static const DSL_char_t USAGE[] =
</xsl:text>
		<xsl:value-of select="$USAGE"/>
		<xsl:text>;
#else
#undef USAGE
#define USAGE ""
#endif /* DSL_DEBUG_DISABLE */
		</xsl:text>
		<xsl:text>
		if(CLI_DSL_CheckHelp(pCommands, USAGE, sOut, nOutSz) == DSL_ERROR)
		{
			return;
		}
		</xsl:text>
		<xsl:if test="string-length($SCAN_1)">
			<xsl:text>ret = DSL_sscanf(pCommands, "</xsl:text>
			<xsl:value-of select="normalize-space($SCAN_1)"/>
			<xsl:text>"</xsl:text>
			<xsl:value-of select="normalize-space($SCAN_2)"/>
			<xsl:text>);
			if(ret != </xsl:text>
			<xsl:value-of select="$SCAN_NUM"/>
			<xsl:text>)
			{
				  DSL_snprintf ( sOut, nOutSz, USAGE );
				return;
			}</xsl:text>
		</xsl:if>
		<xsl:if test="contains($USAGE,'nDevice')">
			<xsl:text>
		CLI_DSL_GetDeviceRange(nDevice, &amp;nStart, &amp;nEnd);
		for(nDevice=nStart;nDevice&lt;nEnd;nDevice++) {
		</xsl:text>
		</xsl:if>
		<xsl:if test="$RETURN_TYPE!='DSL_void_t'">
			<xsl:text>ret = </xsl:text>
		</xsl:if>
		<xsl:value-of select="$NAME"/>
		<xsl:text>( </xsl:text>
		<xsl:apply-templates select="attributelist/parmlist/parm"/>
		<xsl:text> );</xsl:text>
		<xsl:text>
			DSL_snprintf(sOut, nOutSz, "nReturn=%d </xsl:text>
		<xsl:value-of select="normalize-space($PRINT_RETURNS_1)"/>
		<xsl:text>" DSL_CRLF, ret</xsl:text>
		<xsl:value-of select="normalize-space($PRINT_RETURNS_2)"/>
		<xsl:text>);</xsl:text>
		<xsl:if test="contains($USAGE,'nDevice')">
			<xsl:text>}</xsl:text>
		</xsl:if>
	</xsl:template>
	<xsl:template match="parmlist">
		<xsl:apply-templates select="parm"/>
	</xsl:template>
	<xsl:template match="parm">
		<xsl:variable name="NAME" select="attributelist/attribute[@name='name']/@value"/>
		<xsl:variable name="TYPE" select="attributelist/attribute[@name='type']/@value"/>
		<xsl:if test="position()!=1"> ,</xsl:if>
		<xsl:if test="starts-with($TYPE,'p.') and $NAME!='devCtx'">
			<xsl:text>&amp;</xsl:text>
		</xsl:if>
		<xsl:value-of select="$NAME"/>
	</xsl:template>
	<xsl:template match="parm" mode="declaration">
		<xsl:variable name="NAME" select="attributelist/attribute[@name='name']/@value"/>
		<xsl:variable name="TYPE" select="attributelist/attribute[@name='type']/@value"/>
		<xsl:variable name="ARRAY">
			<xsl:value-of select="substring-before(substring-after(//attribute[@name=$TYPE]/@value,'a('),')')"/>
		</xsl:variable>
		<xsl:variable name="ARRAYTYPE">
			<xsl:value-of select="substring-after(substring-after(//attribute[@name=$TYPE]/@value,'a('),').')"/>
		</xsl:variable>
		<xsl:variable name="NEW_TYPE">
			<xsl:choose>
				<xsl:when test="starts-with($TYPE,'p.p.')">
					<xsl:value-of select="substring-after($TYPE,'p.p.')"/>
					<xsl:text> **</xsl:text>
				</xsl:when>
				<xsl:when test="starts-with($TYPE,'p.q(const).')">
					<xsl:value-of select="substring-after($TYPE,'p.q(const).')"/>
				</xsl:when>
				<xsl:when test="starts-with($TYPE,'p.')">
					<xsl:value-of select="substring-after($TYPE,'p.')"/>
				</xsl:when>
				<xsl:when test="starts-with($TYPE,'q(const).')">
					<xsl:value-of select="substring-after($TYPE,'q(const).')"/>
				</xsl:when>
				<xsl:when test="$ARRAY!=''">
					<xsl:value-of select="$ARRAYTYPE"/>
				</xsl:when>
				<xsl:otherwise>
					<xsl:value-of select="$TYPE"/>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:variable>
		<xsl:value-of select="$NEW_TYPE"/>
		<xsl:text> </xsl:text>
		<xsl:value-of select="$NAME"/>
		<xsl:if test="$ARRAY!=''">
			<xsl:text>[</xsl:text><xsl:value-of select="$ARRAY"/>
			<xsl:text>]</xsl:text>
		</xsl:if>
		<xsl:text>;
		</xsl:text>
	</xsl:template>
	<xsl:template match="parm" mode="help_in">
		<xsl:variable name="NAME" select="attributelist/attribute[@name='name']/@value"/>
		<xsl:if test="$NAME!='devCtx'">
   		<xsl:variable name="TYPE" select="attributelist/attribute[@name='type']/@value"/>
   		<xsl:variable name="X1" select="//cdecl/attributelist[attribute[@name='name']/@value=$TYPE]"/>
   		<xsl:variable name="ARRAY">
   			<xsl:value-of select="substring-before(substring-after($X1//attribute[@name='decl']/@value,'a('),')')"/>
   		</xsl:variable>
   		<xsl:variable name="ARRAYTYPE">
   			<xsl:value-of select="$X1//attribute[@name='type']/@value"/>
   		</xsl:variable>
			<xsl:choose>
				<xsl:when test="starts-with($TYPE,'p.p.')">
				</xsl:when>
				<xsl:when test="starts-with($TYPE,'p.q(const).')">
					<xsl:call-template name="complex_help">
						<xsl:with-param name="TYPE" select="substring-after($TYPE,'p.q(const).')"/>
						<xsl:with-param name="ARRAY" select="$ARRAY"/>
					</xsl:call-template>
				</xsl:when>
				<xsl:when test="starts-with($TYPE,'p.')">
					<!-- ignore non const pointer, this are not inputs -->
				</xsl:when>
				<xsl:when test="starts-with($TYPE,'q(const).')">
					<xsl:call-template name="printEnumHelp">
						<xsl:with-param name="TYPE" select="substring-after($TYPE,'q(const).')"/>
						<xsl:with-param name="NAME" select="$NAME"/>
						<xsl:with-param name="ARRAY" select="$ARRAY"/>
					</xsl:call-template>
				</xsl:when>
				<xsl:otherwise>
					<xsl:choose>
						<xsl:when test="$ARRAY!=''">
							<xsl:call-template name="printEnumHelp">
								<xsl:with-param name="TYPE" select="$ARRAYTYPE"/>
								<xsl:with-param name="NAME" select="$NAME"/>
								<xsl:with-param name="ARRAY" select="$ARRAY"/>
							</xsl:call-template>
						</xsl:when>
						<xsl:otherwise>
							<xsl:call-template name="printEnumHelp">
								<xsl:with-param name="TYPE" select="$TYPE"/>
								<xsl:with-param name="NAME" select="$NAME"/>
								<xsl:with-param name="ARRAY" select="$ARRAY"/>
							</xsl:call-template>
						</xsl:otherwise>
					</xsl:choose>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:if>
	</xsl:template>
	<xsl:template match="parm" mode="help_out">
		<xsl:variable name="NAME" select="attributelist/attribute[@name='name']/@value"/>
		<xsl:if test="$NAME!='devCtx'">
   		<xsl:variable name="TYPE" select="attributelist/attribute[@name='type']/@value"/>
   		<xsl:variable name="X1" select="//cdecl/attributelist[attribute[@name='name']/@value=$TYPE]"/>
   		<xsl:variable name="ARRAY">
   			<xsl:value-of select="substring-before(substring-after($X1//attribute[@name='decl']/@value,'a('),')')"/>
   		</xsl:variable>
   		<xsl:variable name="ARRAYTYPE">
   			<xsl:value-of select="$X1//attribute[@name='type']/@value"/>
   		</xsl:variable>
			<xsl:choose>
				<xsl:when test="starts-with($TYPE,'p.p.')">
				</xsl:when>
				<xsl:when test="starts-with($TYPE,'p.q(const).')">
				</xsl:when>
				<xsl:when test="starts-with($TYPE,'p.')">
					<xsl:choose>
						<xsl:when test="//enum[attributelist/attribute[@name='name' and @value=substring-after($TYPE,'p.')]]">
							<xsl:call-template name="printEnumHelp">
								<xsl:with-param name="TYPE" select="substring-after($TYPE,'p.')"/>
								<xsl:with-param name="NAME" select="$NAME"/>
								<xsl:with-param name="ARRAY" select="$ARRAY"/>
							</xsl:call-template>
						</xsl:when>
						<xsl:otherwise>
							<xsl:call-template name="printEnumHelp">
								<xsl:with-param name="TYPE" select="substring-after($TYPE,'p.')"/>
								<xsl:with-param name="NAME" select="$NAME"/>
								<xsl:with-param name="ARRAY" select="$ARRAY"/>
							</xsl:call-template>
							<!--
							FIXME complex help need to be added
							
							<xsl:call-template name="complex_help">
								<xsl:with-param name="TYPE" select="substring-after($TYPE,'p.')"/>
								<xsl:with-param name="NAME" select="$NAME"/>
								<xsl:with-param name="ARRAY" select="$ARRAY"/>
							</xsl:call-template>
							-->
						</xsl:otherwise>
					</xsl:choose>
				</xsl:when>
				<xsl:when test="starts-with($TYPE,'q(const).')">
					<xsl:call-template name="printEnumHelp">
						<xsl:with-param name="TYPE" select="substring-after($TYPE,'q(const).')"/>
						<xsl:with-param name="NAME" select="$NAME"/>
						<xsl:with-param name="ARRAY" select="$ARRAY"/>
					</xsl:call-template>
				</xsl:when>
				<xsl:otherwise>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:if>
	</xsl:template>
	<xsl:template match="parm" mode="scan_1">
		<xsl:variable name="NAME" select="attributelist/attribute[@name='name']/@value"/>
		<xsl:if test="$NAME!='devCtx'">
   		<xsl:variable name="TYPE" select="attributelist/attribute[@name='type']/@value"/>
   		<xsl:variable name="X1" select="//cdecl/attributelist[attribute[@name='name']/@value=$TYPE]"/>
   		<xsl:variable name="ARRAY">
   				<xsl:value-of select="substring-before(substring-after($X1//attribute[@name='decl']/@value,'a('),')')"/>
   		</xsl:variable>
   		<xsl:variable name="ARRAYTYPE">
   				<xsl:value-of select="$X1//attribute[@name='type']/@value"/>
   		</xsl:variable>
			<xsl:choose>
				<xsl:when test="starts-with($TYPE,'p.p.')">
				</xsl:when>
				<xsl:when test="starts-with($TYPE,'p.q(const).')">
					<xsl:call-template name="complex_uid_scan">
						<xsl:with-param name="TYPE" select="substring-after($TYPE,'p.q(const).')"/>
					</xsl:call-template>
				</xsl:when>
				<xsl:when test="starts-with($TYPE,'q(const).')">
					<xsl:call-template name="uid_scan">
						<xsl:with-param name="TYPE" select="substring-after($TYPE,'q(const).')"/>
						<xsl:with-param name="ARRAY" select="$ARRAY"/>
					</xsl:call-template>
				</xsl:when>
				<xsl:when test="starts-with($TYPE,'p.')">
					<!-- ignore non const pointer, this are not inputs -->
				</xsl:when>
				<xsl:otherwise>
					<xsl:choose>
						<xsl:when test="normalize-space($ARRAY)!=''">
							<xsl:call-template name="uid_scan">
								<xsl:with-param name="TYPE" select="$ARRAYTYPE"/>
								<xsl:with-param name="ARRAY" select="$ARRAY"/>
							</xsl:call-template>
						</xsl:when>
						<xsl:otherwise>
							<xsl:call-template name="uid_scan">
								<xsl:with-param name="TYPE" select="$TYPE"/>
								<xsl:with-param name="ARRAY" select="$ARRAY"/>
							</xsl:call-template>
						</xsl:otherwise>
					</xsl:choose>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:if>
	</xsl:template>
	<xsl:template match="parm" mode="scan_2">
		<xsl:variable name="NAME" select="attributelist/attribute[@name='name']/@value"/>
		<xsl:if test="$NAME!='devCtx'">
   		<xsl:variable name="TYPE" select="attributelist/attribute[@name='type']/@value"/>
   		<xsl:variable name="X1" select="//cdecl/attributelist[attribute[@name='name']/@value=$TYPE]"/>
   		<xsl:variable name="ARRAY">
  				<xsl:value-of select="substring-before(substring-after($X1//attribute[@name='decl']/@value,'a('),')')"/>
   		</xsl:variable>
   		<xsl:variable name="ARRAYTYPE">
  				<xsl:value-of select="$X1//attribute[@name='type']/@value"/>
   		</xsl:variable>
			<xsl:choose>
				<xsl:when test="starts-with($TYPE,'p.p.')">
				</xsl:when>
				<xsl:when test="starts-with($TYPE,'p.q(const).')">
					<xsl:call-template name="complex_scan_2">
						<xsl:with-param name="NAME" select="$NAME"/>
						<xsl:with-param name="TYPE" select="substring-after($TYPE,'p.q(const).')"/>
					</xsl:call-template>
				</xsl:when>
				<xsl:when test="starts-with($TYPE,'p.')">
					<!-- ignore non const pointer, this are not inputs -->
				</xsl:when>
				<xsl:when test="starts-with($TYPE,'q(const).')">
					<xsl:call-template name="element_names_scan">
						<xsl:with-param name="NAME" select="$NAME"/>
						<xsl:with-param name="TYPE" select="substring-after($TYPE,'q(const).')"/>
						<xsl:with-param name="AMP">&amp;</xsl:with-param>
						<xsl:with-param name="ARRAY" select="$ARRAY"/>
					</xsl:call-template>
				</xsl:when>
				<xsl:otherwise>
					<xsl:choose>					
						<xsl:when test="$ARRAY!=''">
							<xsl:call-template name="element_names_scan">
								<xsl:with-param name="NAME" select="$NAME"/>
								<xsl:with-param name="TYPE" select="$ARRAYTYPE"/>
								<xsl:with-param name="AMP">&amp;</xsl:with-param>
								<xsl:with-param name="ARRAY" select="$ARRAY"/>
							</xsl:call-template>
						</xsl:when>
						<xsl:otherwise>
							<xsl:call-template name="element_names_scan">
								<xsl:with-param name="NAME" select="$NAME"/>
								<xsl:with-param name="TYPE" select="$TYPE"/>
								<xsl:with-param name="AMP">&amp;</xsl:with-param>
								<xsl:with-param name="ARRAY" select="$ARRAY"/>
							</xsl:call-template>
						</xsl:otherwise>
					</xsl:choose>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:if>
	</xsl:template>
	<xsl:template match="parm" mode="print_returns_1">
		<xsl:variable name="NAME" select="attributelist/attribute[@name='name']/@value"/>
		<xsl:if test="$NAME!='devCtx'">
   		<xsl:variable name="TYPE" select="attributelist/attribute[@name='type']/@value"/>
   		<xsl:variable name="X1" select="//cdecl/attributelist[attribute[@name='name']/@value=$TYPE]"/>
   		<xsl:variable name="ARRAY">
 				<xsl:value-of select="substring-before(substring-after($X1//attribute[@name='decl']/@value,'a('),')')"/>
   		</xsl:variable>
   		<xsl:variable name="ARRAYTYPE">
  				<xsl:value-of select="$X1//attribute[@name='type']/@value"/>
   		</xsl:variable>
			<xsl:choose>
				<xsl:when test="starts-with($TYPE,'q(const).')">
					<xsl:call-template name="uid_print">
						<xsl:with-param name="TYPE" select="substring-after($TYPE,'q(const).')"/>
						<xsl:with-param name="ARRAY" select="$ARRAY"/>
						<xsl:with-param name="NAME" select="$NAME"/>
					</xsl:call-template>
				</xsl:when>
				<xsl:when test="starts-with($TYPE,'p.p.')">
					<xsl:call-template name="uid_print">
						<xsl:with-param name="TYPE" select="substring-after($TYPE,'p.p.')"/>
						<xsl:with-param name="ARRAY" select="$ARRAY"/>
						<xsl:with-param name="NAME" select="$NAME"/>
					</xsl:call-template>
				</xsl:when>
				<xsl:when test="starts-with($TYPE,'p.')">
					<xsl:call-template name="uid_print">
						<xsl:with-param name="TYPE" select="substring-after($TYPE,'p.')"/>
						<xsl:with-param name="ARRAY" select="$ARRAY"/>
						<xsl:with-param name="NAME" select="$NAME"/>
					</xsl:call-template>
				</xsl:when>
				<xsl:otherwise>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:if>
	</xsl:template>
	<xsl:template match="parm" mode="print_returns_2">
		<xsl:variable name="NAME" select="attributelist/attribute[@name='name']/@value"/>
		<xsl:if test="$NAME!='devCtx'">
   		<xsl:variable name="TYPE" select="attributelist/attribute[@name='type']/@value"/>
   		<xsl:variable name="X1" select="//cdecl/attributelist[attribute[@name='name']/@value=$TYPE]"/>
   		<xsl:variable name="ARRAY">
   			<xsl:value-of select="substring-before(substring-after($X1//attribute[@name='decl']/@value,'a('),')')"/>
   		</xsl:variable>
   		<xsl:variable name="ARRAYTYPE">
   			<xsl:value-of select="$X1//attribute[@name='type']/@value"/>
   		</xsl:variable>
			<xsl:choose>
				<xsl:when test="starts-with($TYPE,'q(const).')">
					<xsl:call-template name="element_names_print">
						<xsl:with-param name="TYPE" select="substring-after($TYPE,'q(const).')"/>
						<xsl:with-param name="ARRAY" select="$ARRAY"/>
						<xsl:with-param name="NAME" select="$NAME"/>
					</xsl:call-template>
				</xsl:when>
				<xsl:when test="starts-with($TYPE,'p.p.')">
					</xsl:when>
				<xsl:when test="starts-with($TYPE,'p.')">
					<xsl:call-template name="element_names_print">
						<xsl:with-param name="NAME" select="$NAME"/>
						<xsl:with-param name="TYPE" select="substring-after($TYPE,'p.')"/>
						<xsl:with-param name="AMP"/>
						<xsl:with-param name="ARRAY" select="$ARRAY"/>
					</xsl:call-template>
				</xsl:when>
				<xsl:otherwise>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:if>
	</xsl:template>
	<xsl:template name="uid_scan">
		<xsl:param name="TYPE"/>
		<xsl:param name="ARRAY"/>
		<xsl:choose>
			<xsl:when test="$ARRAY='' and contains($TYPE,'_uint32_t')"> %u</xsl:when>
			<xsl:when test="$ARRAY='' and contains($TYPE,'_uint16_t')"> %hu</xsl:when>
			<xsl:when test="$ARRAY='' and contains($TYPE,'_uint8_t')"> %bu</xsl:when>
			<xsl:when test="$ARRAY='' and contains($TYPE,'_int32_t')"> %d</xsl:when>
			<xsl:when test="$ARRAY='' and contains($TYPE,'_int16_t')"> %hd</xsl:when>
			<xsl:when test="$ARRAY='' and contains($TYPE,'_int8_t')"> %bd</xsl:when>
			<xsl:when test="$ARRAY='' and contains($TYPE,'_int_t')"> %d</xsl:when>
			<xsl:when test="$ARRAY='' and contains($TYPE,'_boolean_t')"> %u</xsl:when>
			<xsl:when test="$ARRAY='' and //enum[attributelist/attribute/@name='name' and attributelist/attribute/@value=$TYPE]"> %u</xsl:when>

			<xsl:when test="$ARRAY!='' and contains($TYPE,'_uint32_t')"> %u[<xsl:value-of select="$ARRAY"/>]</xsl:when>
			<xsl:when test="$ARRAY!='' and contains($TYPE,'_uint16_t')"> %hu[<xsl:value-of select="$ARRAY"/>]</xsl:when>
			<xsl:when test="$ARRAY!='' and contains($TYPE,'_uint8_t')"> %bu[<xsl:value-of select="$ARRAY"/>]</xsl:when>
			<xsl:when test="$ARRAY!='' and contains($TYPE,'_int32_t')"> %d[<xsl:value-of select="$ARRAY"/>]</xsl:when>
			<xsl:when test="$ARRAY!='' and contains($TYPE,'_int16_t')"> %hd[<xsl:value-of select="$ARRAY"/>]</xsl:when>
			<xsl:when test="$ARRAY!='' and contains($TYPE,'_int8_t')"> %bd[<xsl:value-of select="$ARRAY"/>]</xsl:when>
			<xsl:when test="$ARRAY!='' and contains($TYPE,'_int_t')"> %d[<xsl:value-of select="$ARRAY"/>]</xsl:when>
			<xsl:when test="$ARRAY!='' and contains($TYPE,'_boolean_t')"> %u[<xsl:value-of select="$ARRAY"/>]</xsl:when>
			<xsl:when test="$ARRAY!='' and //enum[attributelist/attribute/@name='name' and attributelist/attribute/@value=$TYPE]"> %u</xsl:when>

			<xsl:when test="$ARRAY!='' and contains($TYPE,'_char_t')"> %s</xsl:when>
			<xsl:otherwise>
				<xsl:call-template name="complex_uid_scan">
					<xsl:with-param name="TYPE" select="$TYPE"/>
					<xsl:with-param name="ARRAY" select="$ARRAY"/>
				</xsl:call-template>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="uid_print">
		<xsl:param name="TYPE"/>
		<xsl:param name="ARRAY"/>
		<xsl:param name="NAME"/>
		<xsl:variable name="NEW_NAME">
			<xsl:if test="$NAME!=''">
				<xsl:text> </xsl:text>
				<xsl:value-of select="$NAME"/>
				<xsl:text>=</xsl:text>
			</xsl:if>
		</xsl:variable>
		<xsl:variable name="ENUM" select="//enum[attributelist/attribute/@name='name' and attributelist/attribute/@value=$TYPE]"/>
		<xsl:choose>
			<xsl:when test="$ARRAY='' and contains($TYPE,'_uint32_t')">
				<xsl:value-of select="$NEW_NAME"/>%u</xsl:when>
			<xsl:when test="$ARRAY='' and contains($TYPE,'_uint16_t')">
				<xsl:value-of select="$NEW_NAME"/>%hu</xsl:when>
			<xsl:when test="$ARRAY='' and contains($TYPE,'_uint8_t')">
				<xsl:value-of select="$NEW_NAME"/>%hu</xsl:when>
			<xsl:when test="$ARRAY='' and contains($TYPE,'_int32_t')">
				<xsl:value-of select="$NEW_NAME"/>%d</xsl:when>
			<xsl:when test="$ARRAY='' and contains($TYPE,'_int16_t')">
				<xsl:value-of select="$NEW_NAME"/>%hd</xsl:when>
			<xsl:when test="$ARRAY='' and contains($TYPE,'_int8_t')">
				<xsl:value-of select="$NEW_NAME"/>%hu</xsl:when>
			<xsl:when test="$ARRAY='' and contains($TYPE,'_int_t')">
				<xsl:value-of select="$NEW_NAME"/>%d</xsl:when>
			<xsl:when test="$ARRAY!='' and contains($TYPE,'_char_t')">
				<xsl:value-of select="$NEW_NAME"/>%s</xsl:when>
			<xsl:when test="$ARRAY='' and contains($TYPE,'_boolean_t')">
				<xsl:value-of select="$NEW_NAME"/>%u</xsl:when>
			<xsl:when test="$ARRAY='' and $ENUM">
				<xsl:value-of select="$NEW_NAME"/>
				<xsl:choose>
					<xsl:when test="contains($ENUM/enumitem[1]/attributelist/attribute[@name='enumvalue']/@value,'0x')">%x</xsl:when>
					<xsl:when test="contains($ENUM/enumitem[1]/attributelist/attribute[@name='enumvalueex']/@value,'0x')">%x</xsl:when>
					<xsl:otherwise>%u</xsl:otherwise>
				</xsl:choose>
			</xsl:when>
			<xsl:otherwise>
				<xsl:call-template name="complex_uid_print">
					<xsl:with-param name="TYPE" select="$TYPE"/>
					<xsl:with-param name="NAME" select="$NAME"/>
				</xsl:call-template>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="element_names_scan">
		<xsl:param name="NAME"/>
		<xsl:param name="TYPE"/>
		<xsl:param name="AMP"/>
		<xsl:param name="ARRAY"/>
		<xsl:choose>
			<xsl:when test="$ARRAY=''">
				<xsl:choose>
					<xsl:when test="contains($TYPE,'_uint32_t')"> , <xsl:value-of select="$AMP"/>
						<xsl:value-of select="$NAME"/>
					</xsl:when>
					<xsl:when test="contains($TYPE,'_uint16_t')"> , <xsl:value-of select="$AMP"/>
						<xsl:value-of select="$NAME"/>
					</xsl:when>
					<xsl:when test="contains($TYPE,'_uint8_t')"> , <xsl:value-of select="$AMP"/>
						<xsl:value-of select="$NAME"/>
					</xsl:when>
					<xsl:when test="contains($TYPE,'_int32_t')"> , <xsl:value-of select="$AMP"/>
						<xsl:value-of select="$NAME"/>
					</xsl:when>
					<xsl:when test="contains($TYPE,'_int16_t')"> , <xsl:value-of select="$AMP"/>
						<xsl:value-of select="$NAME"/>
					</xsl:when>
					<xsl:when test="contains($TYPE,'_int8_t')"> , <xsl:value-of select="$AMP"/>
						<xsl:value-of select="$NAME"/>
					</xsl:when>
					<xsl:when test="contains($TYPE,'_int_t')"> , <xsl:value-of select="$AMP"/>
						<xsl:value-of select="$NAME"/>
					</xsl:when>
					<xsl:when test="$ARRAY!='' and contains($TYPE,'_char_t')"> , <xsl:value-of select="$AMP"/>
						<xsl:value-of select="$NAME"/>
					</xsl:when>
					<xsl:when test="contains($TYPE,'_char_t')"> , <xsl:value-of select="$AMP"/>
						<xsl:value-of select="$NAME"/>
					</xsl:when>
					<xsl:when test="contains($TYPE,'_boolean_t')"> , <xsl:value-of select="$AMP"/>
						<xsl:value-of select="$NAME"/>
					</xsl:when>
					<xsl:when test="//enum[attributelist/attribute/@name='name' and attributelist/attribute/@value=$TYPE]">
						, <xsl:value-of select="$AMP"/>
						<xsl:value-of select="$NAME"/>
					</xsl:when>
					<xsl:otherwise>
						<xsl:call-template name="complex_element_names_scan">
							<xsl:with-param name="NAME" select="$NAME"/>
							<xsl:with-param name="TYPE" select="$TYPE"/>
							<xsl:with-param name="AMP" select="$AMP"/>
						</xsl:call-template>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:when>
			<xsl:otherwise>
				<xsl:choose>
					<xsl:when test="contains($TYPE,'_uint32_t')"> , <xsl:value-of select="$AMP"/>
						<xsl:value-of select="$NAME"/>[0]
					</xsl:when>
					<xsl:when test="contains($TYPE,'_uint16_t')"> , <xsl:value-of select="$AMP"/>
						<xsl:value-of select="$NAME"/>[0]
					</xsl:when>
					<xsl:when test="contains($TYPE,'_uint8_t')"> , <xsl:value-of select="$AMP"/>
						<xsl:value-of select="$NAME"/>[0]
					</xsl:when>
					<xsl:when test="contains($TYPE,'_int32_t')"> , <xsl:value-of select="$AMP"/>
						<xsl:value-of select="$NAME"/>[0]
					</xsl:when>
					<xsl:when test="contains($TYPE,'_int16_t')"> , <xsl:value-of select="$AMP"/>
						<xsl:value-of select="$NAME"/>[0]
					</xsl:when>
					<xsl:when test="contains($TYPE,'_int8_t')"> , <xsl:value-of select="$AMP"/>
						<xsl:value-of select="$NAME"/>[0]
					</xsl:when>
					<xsl:when test="contains($TYPE,'_int_t')"> , <xsl:value-of select="$AMP"/>
						<xsl:value-of select="$NAME"/>[0]
					</xsl:when>
					<xsl:when test="$ARRAY!='' and contains($TYPE,'_char_t')"> , <xsl:value-of select="$AMP"/>
						<xsl:value-of select="$NAME"/>[0]
					</xsl:when>
					<xsl:when test="contains($TYPE,'_char_t')"> , <xsl:value-of select="$AMP"/>
						<xsl:value-of select="$NAME"/>[0]
					</xsl:when>
					<xsl:when test="contains($TYPE,'_boolean_t')"> , <xsl:value-of select="$AMP"/>
						<xsl:value-of select="$NAME"/>[0]
					</xsl:when>
					<xsl:when test="//enum[attributelist/attribute/@name='name' and attributelist/attribute/@value=$TYPE]">
						, <xsl:value-of select="$AMP"/>
						<xsl:value-of select="$NAME"/>[0]
					</xsl:when>
					<xsl:otherwise>
						<xsl:call-template name="complex_element_names_scan">
							<xsl:with-param name="NAME" select="$NAME"/>
							<xsl:with-param name="TYPE" select="$TYPE"/>
							<xsl:with-param name="AMP" select="$AMP"/>
						</xsl:call-template>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="element_names_print">
		<xsl:param name="NAME"/>
		<xsl:param name="TYPE"/>
		<xsl:param name="AMP"/>
		<xsl:param name="ARRAY"/>
		<xsl:choose>
			<xsl:when test="$ARRAY='' and contains($TYPE,'_uint32_t')"> , <xsl:value-of select="$AMP"/>
				<xsl:value-of select="$NAME"/>
			</xsl:when>
			<xsl:when test="$ARRAY='' and contains($TYPE,'_uint16_t')"> , <xsl:value-of select="$AMP"/>
				<xsl:value-of select="$NAME"/>
			</xsl:when>
			<xsl:when test="$ARRAY='' and contains($TYPE,'_uint8_t')"> , <xsl:value-of select="$AMP"/>
				<xsl:value-of select="$NAME"/>
			</xsl:when>
			<xsl:when test="$ARRAY='' and contains($TYPE,'_int32_t')"> , <xsl:value-of select="$AMP"/>
				<xsl:value-of select="$NAME"/>
			</xsl:when>
			<xsl:when test="$ARRAY='' and contains($TYPE,'_int16_t')"> , <xsl:value-of select="$AMP"/>
				<xsl:value-of select="$NAME"/>
			</xsl:when>
			<xsl:when test="$ARRAY='' and contains($TYPE,'_int8_t')"> , <xsl:value-of select="$AMP"/>
				<xsl:value-of select="$NAME"/>
			</xsl:when>
			<xsl:when test="$ARRAY='' and contains($TYPE,'_int_t')"> , <xsl:value-of select="$AMP"/>
				<xsl:value-of select="$NAME"/>
			</xsl:when>
			<xsl:when test="$ARRAY!='' and contains($TYPE,'_char_t')"> , <xsl:value-of select="$AMP"/>
				<xsl:value-of select="$NAME"/>
			</xsl:when>
			<xsl:when test="$ARRAY='' and contains($TYPE,'_char_t')"> , <xsl:value-of select="$AMP"/>
				<xsl:value-of select="$NAME"/>
			</xsl:when>
			<xsl:when test="$ARRAY='' and contains($TYPE,'_boolean_t')"> , <xsl:value-of select="$AMP"/>
				<xsl:value-of select="$NAME"/>
			</xsl:when>
			<xsl:when test="//enum[attributelist/attribute/@name='name' and attributelist/attribute/@value=$TYPE]">
				, <xsl:value-of select="$AMP"/>
				<xsl:value-of select="$NAME"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:call-template name="complex_element_names_print">
					<xsl:with-param name="NAME" select="$NAME"/>
					<xsl:with-param name="TYPE" select="$TYPE"/>
				</xsl:call-template>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="complex_help">
		<xsl:param name="TYPE"/>
		<xsl:param name="ARRAY"/>
		<xsl:variable name="X">
			<xsl:variable name="X1" select="//class[attributelist/attribute/@name='name' and attributelist/attribute/@value=$TYPE]/cdecl"/>
			<xsl:variable name="X2" select="//class[attributelist/attribute/@name='name' and attributelist/attribute/@value=substring($TYPE, 1, string-length($TYPE)-2)]/cdecl"/>
		</xsl:variable>
		<xsl:if test="$X">
			<xsl:for-each select="$X/attributelist">
				<xsl:variable name="NAME">
					<xsl:value-of select="attribute[@name='type']/@value"/>
				</xsl:variable>
				<xsl:call-template name="printEnumHelp">
					<xsl:with-param name="TYPE" select="$NAME"/>
					<xsl:with-param name="NAME" select="attribute[@name='name']/@value"/>
					<xsl:with-param name="ARRAY" select="$ARRAY"/>
				</xsl:call-template>
			</xsl:for-each>
		</xsl:if>
	</xsl:template>
	<xsl:template name="complex_uid_scan">
		<xsl:param name="TYPE"/>
		<xsl:variable name="X" select="//class[attributelist/attribute/@name='name' and attributelist/attribute[@value=$TYPE or @value=substring($TYPE, 1, string-length($TYPE)-2)]]/cdecl"/>
		<xsl:if test="$X">
			<xsl:for-each select="$X/attributelist">
				<xsl:variable name="ARRAY">
					<xsl:value-of select="substring-before(substring-after(attribute[@name='decl']/@value,'a('),')')"/>
				</xsl:variable>
				<xsl:text> </xsl:text>
				<xsl:call-template name="uid_scan">
					<xsl:with-param name="TYPE" select="attribute[@name='type']/@value"/>
					<xsl:with-param name="ARRAY" select="$ARRAY"/>
				</xsl:call-template>
			</xsl:for-each>
		</xsl:if>			
	</xsl:template>
	<xsl:template name="complex_uid_print">
		<xsl:param name="TYPE"/>
		<xsl:param name="NAME"/>
		<xsl:variable name="X" select="//class[attributelist/attribute/@name='name' and attributelist/attribute[@value=$TYPE or @value=substring($TYPE, 1, string-length($TYPE)-2)]]/cdecl"/>
		<xsl:if test="$X">
			<xsl:for-each select="$X/attributelist">
				<xsl:variable name="ARRAY">
					<xsl:value-of select="substring-before(substring-after(attribute[@name='decl']/@value,'a('),')')"/>
				</xsl:variable>
				<xsl:text> </xsl:text>
				<xsl:if test="$NAME!=''">
					<xsl:call-template name="uid_print">
						<xsl:with-param name="TYPE" select="attribute[@name='type']/@value"/>
						<xsl:with-param name="ARRAY" select="$ARRAY"/>
						<xsl:with-param name="NAME" select="attribute[@name='name']/@value"/>
					</xsl:call-template>
				</xsl:if>
				<xsl:if test="$NAME=''">
					<xsl:call-template name="uid_print">
						<xsl:with-param name="TYPE" select="attribute[@name='type']/@value"/>
						<xsl:with-param name="ARRAY" select="$ARRAY"/>
					</xsl:call-template>
				</xsl:if>
			</xsl:for-each>
		</xsl:if>			
	</xsl:template>
	<xsl:template name="complex_scan_2">
		<xsl:param name="NAME"/>
		<xsl:param name="TYPE"/>
		<xsl:variable name="X" select="//class[attributelist/attribute/@name='name' and attributelist/attribute[@value=$TYPE or @value=substring($TYPE, 1, string-length($TYPE)-2)]]/cdecl"/>
		<xsl:if test="$X">
			<xsl:for-each select="$X/attributelist">
				<xsl:variable name="ARRAY">
					<xsl:value-of select="substring-before(substring-after(attribute[@name='decl']/@value,'a('),')')"/>
				</xsl:variable>
				<xsl:call-template name="element_names_scan">
					<xsl:with-param name="NAME">
						<xsl:value-of select="$NAME"/>
						<xsl:text>.</xsl:text>
						<xsl:value-of select="attribute[@name='name']/@value"/>
					</xsl:with-param>
					<xsl:with-param name="TYPE" select="attribute[@name='type']/@value"/>
					<xsl:with-param name="AMP">&amp;</xsl:with-param>
					<xsl:with-param name="ARRAY" select="$ARRAY"/>
				</xsl:call-template>
			</xsl:for-each>
		</xsl:if>
	</xsl:template>
	<xsl:template name="complex_element_names_scan">
		<xsl:param name="NAME"/>
		<xsl:param name="TYPE"/>
		<xsl:param name="AMP"/>
		<xsl:variable name="X" select="//class[attributelist/attribute/@name='name' and attributelist/attribute[@value=$TYPE or @value=substring($TYPE, 1, string-length($TYPE)-2)]]/cdecl"/>
		<xsl:if test="$X">
			<xsl:for-each select="$X/attributelist">
				<xsl:variable name="COMPLEX_NAME">
					<xsl:value-of select="$NAME"/>.<xsl:value-of select="attribute[@name='name']/@value"/>
				</xsl:variable>
				<xsl:variable name="ARRAY">
					<xsl:value-of select="substring-before(substring-after(attribute[@name='decl']/@value,'a('),')')"/>
				</xsl:variable>
				<xsl:call-template name="element_names_scan">
					<xsl:with-param name="NAME" select="$COMPLEX_NAME"/>
					<xsl:with-param name="TYPE" select="attribute[@name='type']/@value"/>
					<xsl:with-param name="ARRAY" select="$ARRAY"/>
					<xsl:with-param name="AMP" select="$AMP"/>
				</xsl:call-template>
			</xsl:for-each>
		</xsl:if>
	</xsl:template>
	<xsl:template name="complex_element_names_print">
		<xsl:param name="NAME"/>
		<xsl:param name="TYPE"/>
		<xsl:variable name="X" select="//class[attributelist/attribute/@name='name' and attributelist/attribute[@value=$TYPE or @value=substring($TYPE, 1, string-length($TYPE)-2)]]/cdecl"/>
		<xsl:if test="$X">
			<xsl:for-each select="$X/attributelist">
				<xsl:variable name="COMPLEX_NAME">
					<xsl:value-of select="$NAME"/>.<xsl:value-of select="attribute[@name='name']/@value"/>
				</xsl:variable>
				<xsl:variable name="ARRAY">
					<xsl:value-of select="substring-before(substring-after(attribute[@name='decl']/@value,'a('),')')"/>
				</xsl:variable>
				<xsl:call-template name="element_names_scan">
					<xsl:with-param name="NAME" select="$COMPLEX_NAME"/>
					<xsl:with-param name="TYPE" select="attribute[@name='type']/@value"/>
					<xsl:with-param name="ARRAY" select="$ARRAY"/>
				</xsl:call-template>
			</xsl:for-each>
		</xsl:if>
	</xsl:template>
	<xsl:template match="enum">
		<xsl:apply-templates select="enumitem"/>
	</xsl:template>
	<xsl:template match="enumitem">
		<xsl:variable name="ORG_NAME" select="attributelist/attribute[@name='name']/@value"/>
		<xsl:variable name="VALUE" select="attributelist/attribute[@name='enumvalue']/@value"/>
		<xsl:variable name="NAME">
			<xsl:choose>
				<xsl:when test="starts-with($ORG_NAME,'DSL_')">
					<xsl:value-of select="substring-after($ORG_NAME, 'DSL_')"/>
				</xsl:when>
				<xsl:otherwise>
					<xsl:value-of select="$ORG_NAME"/>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:variable>
		<xsl:if test="not(contains($ORG_NAME,'_LAST') and substring-after($ORG_NAME,'_LAST')='')">
			<xsl:text>"   </xsl:text>
			<xsl:value-of select="translate($NAME,'ABCDEFGHIJKLMNOPQRSTUVWXYZ_','abcdefghijklmnopqrstuvwxyz ')"/>
			<xsl:text> = </xsl:text>
			<xsl:value-of select="$VALUE"/>
			<xsl:text>" DSL_CRLF	\
</xsl:text>
		</xsl:if>
	</xsl:template>
	<xsl:template name="printEnumHelp">
		<xsl:param name="TYPE"/>
		<xsl:param name="NAME"/>
		<xsl:param name="ARRAY"/>
		<xsl:variable name="ENUM_HELP">
			<xsl:apply-templates select="//enum[attributelist/attribute[@name='name' and @value=$TYPE]]"/>
		</xsl:variable>
		<xsl:text>"- </xsl:text>
		<xsl:value-of select="$TYPE"/>
		<xsl:text> </xsl:text>
		<xsl:value-of select="$NAME"/>
		<xsl:if test="$ARRAY!=''">[<xsl:value-of select="$ARRAY"/>]</xsl:if>
		<xsl:text>" DSL_CRLF \
</xsl:text>
		<xsl:choose>
			<xsl:when test="starts-with($ENUM_HELP,',')">
				<xsl:value-of select="substring-after($ENUM_HELP,',')"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="$ENUM_HELP"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
</xsl:stylesheet>
