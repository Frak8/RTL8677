/************************************************************/
/*                                                          */
/*  Filename: uitask.c                                      */
/*                                                          */
/*  Description:    This function is currently used to      */
/*                  debugging only. Used to trigger cmd     */
/*                  requests.                               */
/*                                                          */
/*  Ikanos Communications 01/2001                           */
/*                                                          */
/*
$Revision: 1.1 $
$Date: 2008/07/18 11:08:39 $
*/
/************************************************************/
/* #includes*/
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#ifdef ALASKA      // header file declarations starts here
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <errno.h>
/*for Message Queues */
#include <sys/ipc.h>
#include <sys/msg.h>
#endif  //ALASKA header file declaration ends here
#include "appconfig.h"
#include "apitype.h"
#include "apistruct.h"
#include "host_ver.h"
#include "notchBnd.h"
#include "uiUtil.h"
#include "oampdb.h" /* IXDP425 */
#include "password.h"
#include "apidef.h"
#include "portmap.h"
#include "pprofile.h"
#include "oampdef.h"
#include "autoStart.h"
#include "apposmacro.h"
#include "oampstruct.h"
//#include "iniapi.h"
#include "HostPtmfApi.h"
#include "consoleUtil.h"
#include "bmetl.h"
#include "oampproto.h"
#include "eocapp.h"
#include "bsp.h"
#include "linecrc.h"
#include "dapi.h"
#ifdef CO_30_DIAGS
#include "diags_mode.h"
#endif

#define RESTART_TASK_PRIORITY 90
#define RESTART_TASK_STACK_SIZE 8192
#define HOST_DBG_API_HB2 (0x40000104)

/* Global vairables */
BYTE pTlStr[512];
BYTE MacAddr[100];
BYTE Test[50];
unsigned int ulRestartTask;
/*extern BYTE BMECodeArray[512*1024];*/
int UserMode = SUPERVISOR_MODE;
ipos_pm_trigger PmTrigger;

/* For reference board menu*/
int menu_num;
//tAPI_REQUEST ApiRequest;
//tPortId Pid;
UINT8 input_uint8;
UINT32 input_uint32;
//int FirstBootup=1;
int PasswordVerified=0;
int ConsoleTimer=CONSOLE_TIMEOUT;
int BandPlan=0;
int SysProvDone;
int MacMenu=0;
int AddrFilterEocSema4;
int doConsoleTimeOut = 1;
#ifdef INI_SUPPORT
static void     MacFilterMenu(void);
#endif// INI_SUPPORT
U8              EnterSixByteMacAddr(U8 *pbEnetAddr);
#if defined(USE_RFM) && defined(VTU_O)
static void     RFMMenu(void);
#endif

#ifdef  BME_CPE_20
static  void    azMemMenu(void);
static sysInfo sInfo;
#endif


/* extern vars */
extern int okToDumpLog;
extern int notResetBme;
extern int autoStart;
extern int IniVer;
#ifdef INI_SUPPORT
extern int dropFrameEnable;
#endif // INI_SUPPORT
extern ipos_port_profile sPortProfiles[];
extern oamp_bme oampBme [IPOS_MAX_BME+1];
extern ipos_pm_counters *pPmCntr24Hrs[IPOS_MAX_BME+1][IPOS_MAX_PORT_PER_BME+1];
/* for RFM download Status */
extern U8 feDldStatus[MAX_NUM_OF_PORTS];
extern U8 remDldImgFlag;
#ifdef INI_SUPPORT
#if defined(P2CPE) || defined(BME_CPE_20)
extern tsIposPtmfEnetAddrFilterCfg      tsEnetAddrFilterConfig;
#endif

#if defined(VTU_O) || (defined (P2CO) && defined (VTU_R)) //Added to support Multiport CPE build
  tsIposPtmfEnetAddrFilterCfg       tsEnetAddrFilterConfig;
#endif
#endif // INI_SUPPORT
extern int pollFreq [50];
extern int poll_index;

void (*func1)(void) = NULL;
void (*func2)(void) = NULL;
/* function prototypes */

/* extern functions */
//extern int sysClkRateGet (void); /* IXDP425 */
//extern UINT32 FlashEraseSector(volatile UINT8 *pSector);
//extern UINT32 FlashWrite(volatile UINT8 *pDest, UINT8 *pSource,UINT32 Length);
extern void processLed (void);
extern int verifyPassword(void);
extern void updateFlashProf(void);
extern void dumpAllBmeStatus(void);
extern void dumpAllPortStatus(void);

extern void bmeDebugInit (void);
extern void bmeDebugHandler (void);
extern int uiMaintenanceMenu (ipos_test_signals * pTestSig);
extern char saveImageVer(char *verString);
extern void displayPerfCntrs(ipos_port_id Pid);
extern void displayPmCounters(ipos_port_id Pid);
extern void displayPMCounters24Hrs (ipos_port_id pid);
extern void InitSdramM (int x16, int OpenPage, int which);
extern void uiRMMMenu( void );
extern void perToneMenu(void);
extern void dbgIniMenu (void);
extern char getSysInfo (char *);
extern void saveSysInfo(char    *);
extern void HostFpgaWrite(BYTE boffset,BYTE bdata);

/* Globals for Host Hot Reset */
int HostReset;  /* 1 indicates that the Host Reset has been initiated */
int HostResync [MAX_NUM_OF_BMES+1]; /* 1 indicates that the Resync is yet to complete for a BME */

extern tBmeStruct BmeStruct[];

extern void uiInternalEocMenu(ipos_port_id pid);
extern void uiBitSwapMenu(ipos_port_id pid);

/* For EOC loopback testing */
extern void uiEocLbStressMenu(void);

/* For Event Log Management (ELM) */

extern void uiElmMenu( void );

/* GPIO API TEST  */
void PrGpioTestMenu(void);

// board configuratio menu
void brd_cfg(void);

#ifdef ALASKA      //functions and extern declarations starts here
void config_VDSL_from_file();
void portProvision(FILE *fp);
int getParamValue(char *line);
void getNextOption(FILE *fp, char *line);
void sysProvOptionMask(FILE *fp);
int getBmePortId_local(ipos_port_id *Pid);
extern sys_port_mapping   sysPortMap[IPOS_MAX_PORTS];
extern void ohmCmdProcess(ipos_port_id pid, char *ohmData);
extern void uiElmProcess(char *elmData);
typedef struct {
        long int mtype;
        int webflag;
        char mtext[300];
}VDSL_MSG_Q;
int webflag=0;

#endif  //ALASKA --- end functions declaration
static char yrStr[] = "2005";
#ifdef PRODUCTION_CODE
/******************************************************************************
*
* autoboot - do automatic boot sequence
*
* RETURNS: Doesn't return if successful (starts execution of booted system).
*/

static void autoboot2 (unsigned int timeout /* timeout time in seconds */)
{
    int kbhit = 1;

    if (timeout != 0)
    {
        IK_PRINTF ("\nPress enter key to stop auto startup...\n");
        kbhit = consoleKbHit(timeout);
    }

    if ((timeout == 0) || (!kbhit))
    {
        IK_PRINTF ("\nauto-booting...\n\n");
        autoStartBME(oampGetBandPlan);
        autoStart = 1;
    }
}

#endif

static void
updatedReportsCb(ipos_port_id portId, U8 UID, U32 uPar,  int status, void *par)
{
    (void) UID;
    (void) uPar;

    printf( "iposUpdatedReportEnable completes for b%dp%d with status %d and par 0x%x\n",
         portId.bmeNum, portId.portNum, status, (int) par
    );
}

int getPortNum (ipos_port_id *pid)
{
    int portnum;
    char  str[256];

    printf ("Enter port number: ");

    gets (str);
    sscanf(str,"%i",&portnum);
    if (getBmePortId(portnum, pid) != IPOS_SUCCESS)
    {
        printf("\nInvalid port number %d", portnum);
        portnum = -1;
        pTlStr[0] = '\0';
    }

    return(portnum);
}


void processTimeout(void)
{
  int i, host_reset_count = 0; 

  for (i=1; i <= MAX_NUM_OF_BMES; i++) {
    if (HostResync [i])
      host_reset_count ++;
  }

#ifdef PRODUCTION_CODE
    if (doConsoleTimeOut && !host_reset_count)
    {
        //printf ("\nTimeout c%i",ConsoleTimer);
        if (ConsoleTimer>0)
        {
            ConsoleTimer--;
        }
        if (((ConsoleTimer==0) && (PasswordVerified == 1))
            || ((ConsoleTimer==0) && (autoStart==0)))
        {
            printf("\nInactivity Time Out");
            printf("\nLogged off from system");
            PasswordVerified=0;
            autoStart = 1;
            //      pmEnable = 1;
        }
    }
#endif
}

#ifndef BUP_DIAGS
void taskUi(void)
{
    int             i,j;
    int             portnum=0,profilenum=99;
    int             bmenum=1;
    int             displayMenu = 1;
    char            hostVer[16];
    ipos_port_id    Pid;
    int             bmeBandPlan;
    U8              pktMode;
    int             portState;
#ifdef ALASKA
    FILE            *vdslout;
#endif

#ifndef ALASKA
    int             portnum=0,profilenum=99;
    int             bmenum=1;
    int             displayMenu = 1;
    char            resetConfirm=0;
    int             portState;
    int             psdMaskLevelIndex;
    float           k0[3] = {0.0, 0.0, 0.0};
    float           k1[3] = {0.0, 0.0, 0.0};
    float           k0_hi[3] = {0.0, 0.0, 0.0};
    float           k1_hi[3] = {0.0, 0.0, 0.0};
    int             TlanEn;
    int             customerID;
    int             key1, key2, key3;
    int             safeMode;
#endif	//NOT ALASKA
#ifdef ALASKA   //variables declaration starts here
    int hard_start=1; //to control hard coded configuration of BME in while(1)
    int mq_id;
    key_t key;
    VDSL_MSG_Q vdsl_msg;
#endif  //ALASKA -- variables declaration ends here
#ifdef INI_SUPPORT
    int linenum,ptmfIndex;
#endif

#ifdef  BME_CPE_20
    ipos_emi_config bmeMemCfg;              /* paramaters for configure bme external memory controller  */
#endif
#ifndef ALASKA
    int             profnum=0;
    int        lineNum=0;
   int idle_counter_check =0, curr_val =0, prev_val =0;
#endif

    strcpy (hostVer,VERSION_STR);
#ifdef LINUX_2_6
    osSetTaskRealTime(1);
#endif

#ifndef ALASKA
    printf ("\n**********************************************************");
    printf ("\n**               Copyright (C) 2000-%s                **", yrStr);
    printf ("\n**          Ikanos Communication, Fremont, CA           **");
    printf ("\n**                All rights reserved.                  **");
    printf ("\n**                                                      **");
    printf ("\n**      Ikanos Programmable Operating System (TM)       **");
    printf ("\n**    Firmware and Application Programming Interface    **");
    printf ("\n**                       for the                        **");
    printf ("\n**         SmartLeap, CleverConnect, FX, and FXS        **");
    printf ("\n**    VDSL/EFM and FX Extension over Copper Chipsets    **");
#ifdef CO_20_BUP_BOARD
    printf ("\n**                    Bring Up Board                    **");
#elif (defined CO_20_REFBOARD_2BME)
    printf ("\n**                 Reference Board 2 BME                **");
#elif (defined CO_20_REFBOARD_1BME)
    printf ("\n**                 Reference Board 1 BME                **");
#elif (defined BUP_DIAGS)
    printf ("\n**                    Bring Up Diags                    **");
#endif
    printf ("\n**                   Version  %-18s        **",hostVer);
    printf ("\n**********************************************************\n\n");
#endif
#ifdef CO_20_EMULATION_BOARD
taskDelay (100);
#endif

/* save the version to the flash */
    //saveImageVer(hostVer); /* IXDP425 */

#ifdef  BME_CPE_20
    //getSysInfo( (char *) &sInfo); /*IXDP425 */
    sInfo.memInfo = 2;		    /*IXDP425 */
    switch(sInfo.memInfo)
    {
    case    0: bmeMemCfg.memType=IPOS_BME_MEM_SRAM;
        break;
    case    1: bmeMemCfg.memType=IPOS_BME_MEM_SDRAM16;
        break;
    case    2:  bmeMemCfg.memType=IPOS_BME_MEM_SDRAM32;
        break;
    default:
        bmeMemCfg.memType=IPOS_BME_MEM_SDRAM16;
    }

    bmeMemCfg.memSize=  IPOS_BME_MEM_DEFAULT;
    bmeMemCfg.clk   =   IPOS_BME_MEM_DEFAULT;
    bmeMemCfg.casDelay= IPOS_BME_MEM_DEFAULT;
    bmeMemCfg.rcDelay=  IPOS_BME_MEM_DEFAULT;
    bmeMemCfg.rPrecharge=IPOS_BME_MEM_DEFAULT;
    bmeMemCfg.rActive=  IPOS_BME_MEM_DEFAULT;
    bmeMemCfg.rCycle    =   IPOS_BME_MEM_DEFAULT;


    if(iposBmeConfigMemBlk(1,&bmeMemCfg)!=IPOS_SUCCESS)
    {
        printf("\n failed to initilize BME memeory parameters \n");
        return;
    }

#elif defined CO_20

    printf("Fusiv autoRestart() Junk\n");
    InitSdramM(1,1,1);
#endif
#if 1
    if (iposTaskSpawn("tRestartTask", RESTART_TASK_PRIORITY, RESTART_TASK_STACK_SIZE, (taskFunc)autoRestart,0, 0, 0) == OS_ERROR)
        printf("Failed to start UI Task\n");
     printf("start autoRestart from UI Task\n");
#endif
#if 0
    if (tskCreate("tRestartTask", RESTART_TASK_PRIORITY, RESTART_TASK_STACK_SIZE, (taskFunc)autoRestart,0, &ulRestartTask) == OS_ERROR)
        printf("Failed to start UI Task\n");
#endif
    // printf("Fusiv autoRestart() 11\n");
#ifdef PRODUCTION_CODE
    for (i = 1; i <= MAX_NUM_OF_BMES; i++)
        printf ("\nBME %d is coming up\n", i);
    for (i = 1; i <= MAX_NUM_OF_BMES; i++)
    {
//      printf ("\nBME %d is coming up\n", i);
        if (i > 1)
            iposTaskDelay (1 * CLOCKS_PER_SEC); // Wait 1 seconds.
        sprintf(pTlStr,"bstart:0:%d;", i);
        ReceiveTLCommand (pTlStr);
    }

//am 4/17/03    iposTaskDelay (20 * CLOCKS_PER_SEC); // Wait 20 seconds.
#ifdef CO_20_EMULATION_BOARD
    {
        extern int bmeReleased;
        while (!bmeReleased) taskDelay (10);
    }
#endif

    for (i = 1; i <= MAX_NUM_OF_BMES; i++)
    {
        // Fusiv break; //manju	 
        j=0;
        while ((oampGetBmeState(i) == uDOWN))
        {
#ifndef ALASKA
            iposTaskDelay (CLOCKS_PER_SEC); //Wait 1 seconds.
#else
            iposTaskDelay (10*CLOCKS_PER_SEC); //Wait 1 seconds. Fusiv
#endif

            j++;
            if(j>30) break;                 // not more than 30 seconds
        }

#if defined CO_20_EMULATION_BOARD || defined CO_50_EMULATION_BOARD
        if(j>45)
#elif CPE_ATM
        if(j>130)
#else
        if(j>30)
#endif
        {
            printf("\nFailed to download BME \n");

#ifdef  BME_CPE_20
            azMemMenu();
            printf("\nPlease power-cycle the system \n");

#endif
            return;
        }
    }
//am 4/17/03    iposTaskDelay (5 * CLOCKS_PER_SEC);  // Wait 5 seconds for BME to fully booted up.

    for (i = 1; i <= MAX_NUM_OF_BMES; i++)
    {
        if ((oampGetBmeState(i) == uREADY) || (oampGetBmeState(i) == uIDLE))
        {
            iposTaskDelay (100);
        }
        HostResync [i] = 0;
    }
    HostReset = 0;

#ifdef CO_30_DIAGS
    // to prevent going into auto mode after manual diags
    if (oampGetDiagsOption == BUP_DIAGS_MANUAL_MODE)
    {
    }
    else
    {
#endif
#ifndef ALASKA
        autoboot2 (oampGetAutoStartWaitTime);
#endif
#ifdef CO_30_DIAGS
    }
#endif

#else
    iposTaskDelay (5 * CLOCKS_PER_SEC); // Wait 5 seconds.
#endif


    /* initialize bme debug handler */
    bmeDebugInit ();

#ifdef ALASKA
    key = ftok("/etc/",'4');
    mq_id = msgget(key, IPC_CREAT | 0660);
#endif //ALASKA

    while (1)
    {
#ifndef PRODUCTION_CODE
        PasswordVerified=1;
#else
#ifndef ALASKA
        while (!PasswordVerified)
        {
            switch (UserMode = verifyPassword())
            {
                case SUPERVISOR_MODE:
                    printf ("\nSupervisor mode");
                    PasswordVerified=1;
                    break;
                case OPERATOR_MODE:
                    printf ("\nOperator mode");
                    PasswordVerified=1;
                    break;
                default:
                    printf ("\nERROR: incorrect password entered");
                    break;
            }
        }
#endif // ALASKA
        ConsoleTimer=CONSOLE_TIMEOUT;
#endif

#ifndef ALASKA
        if (UserMode==SUPERVISOR_MODE)
        {
            autoStart = 0;
#endif // ALASKA
#ifdef ALASKA
        if( hard_start )
        {
          config_VDSL_from_file();

          if (oampGetUtopiaMode == 0x80 || oampGetUtopiaMode == 0x91)
            pktMode = 128;  //PTM Mode
          else if(oampGetUtopiaMode == 0xc0 || oampGetUtopiaMode == 0xc1)
            pktMode = 0xc0; //EFM Mode
          else
            pktMode = 0;    //ATM Mode

          bmeBandPlan = getBmeBandPlan (oampGetBandPlan);
          sprintf(pTlStr,"sysprov:0:1:33:55:17185:1:%i:53:0:%d:%d;",pktMode, bmeBandPlan, IPOS_MAX_PORTS / IPOS_MAX_BME);
          if (oampGetBmeState(1) == uIDLE)
          {
            setPortMap(1, bmeBandPlan);
          }
          ReceiveTLCommand (pTlStr);
          sleep(3);

          sprintf (pTlStr,"pprov:0:1:1:2;");
          ReceiveTLCommand (pTlStr);
          sleep(3);

          portState = oampBme[1].oampPort[1].portState;
          if (portState==uSHOWTIME || portState==uACTIVATING ||
              portState==uLOOPBACK)
          {
            printf ("\nPORT_START fail: Port is not in idle state");
          }
          else
          {
            sprintf(pTlStr,"pstart:0:1:1;");
            ReceiveTLCommand (pTlStr);
          }
          pTlStr[0] = '\0';
          hard_start = 0;
          //autoStart = 1;
        }
#endif  //ALASKA
#ifndef ALASKA
//          pmEnable = 0;
        } else
        {
            autoStart = 1;
//          pmEnable = 1;
        }

        if (displayMenu)
        {
            printf ("\n\n\n      BME Reference board API Menu");
            printf ("\nIkanos Communications Copyright 2000-%s", yrStr);
            printf ("\n             Version %-16s",hostVer);
            printf ("\n=========================================\n");
            if (UserMode==SUPERVISOR_MODE)
            {
                printf ("\n    1) Initiate Host Hot Reset");
                printf ("\n    2) Initiate Reset BME command");
                printf ("\n    3) Configure System Provision (default values)");
                printf ("\n    4) Configure Port Provision");
                printf ("\n    5) Initiate Port Start command");
                printf ("\n    6) Initiate Port Reset command");
                printf ("\n    7) Initiate Port Stop command");
#ifdef VTU_O
                printf ("\n    8) Initiate Port Start Far End Command");
#endif
            printf ("\n    9) Start Loopback Test");
            }
            printf ("\n   10) Request Brief Port Status");
            printf ("\n   11) Request Extended Port Status");
            printf ("\n   12) Display Performance Counters");
            printf ("\n   13) Get Near End SNR Margin and Attenuation");
#ifdef VTU_O
            printf ("\n   14) Retrieve Remote Performance Counters");
#endif
            printf ("\n   15) Display User Logs");
            printf ("\n   16) Clear User Logs");
#ifdef VTU_O
            printf ("\n   17) Get Far End SNR Margin and Attenuation");
#endif
            printf ("\n   20) Display this menu");
            if (UserMode==SUPERVISOR_MODE)
            {
                printf ("\n   21) Modify Port Provision");
                printf ("\n   22) Modify console password");
                printf ("\n   23) Port Profile Mapping");
#ifndef CPE_40
                printf ("\n   24) Packet Transfer Mode Selection");
#endif
                printf ("\n   25) System Provision Option Mask");

//              printf ("\n   30) Drop Frame Control");
                printf ("\n   31) INI CRC Threshold");

#if defined(VTU_R) && (defined(P2CPE) || defined(BME_CPE_20))
                printf ("\n   32) Ethernet Address Filtering Configuration ");
#endif
#ifdef VTU_O
                printf ("\n   32) Remote Ethernet Address Filtering Configuration ");
                printf ("\n   33) Ethernet Flow Control");
                printf ("\n   40) Perform EOC loopback test");
                //      printf ("\n   80) Download CPE code from serial port");
                //      printf ("\n   81) Download CPE code to remote CPE");
#endif

/* For EOC loopback testing */

#ifdef VTU_O
                printf ("\n   41) EOC Loopback Stress Test Management");
#endif
#ifdef VTU_R
                printf ("\n   41) Port Error Count Management");
#endif
                        printf ("\n   42) Event Log Management");
#ifdef VTU_O
                        printf ("\n   43) Remote Modem Management");
#endif
#ifdef VTU_R
                        printf ("\n   43) Local Modem Management");
#endif

#ifdef  USE_RFM
#ifdef  VTU_O

                printf ("\n   50) Remote Firmware Management");

#endif
#endif
                printf("\n   55) Board Configuration Management");
                printf("\n   56) OAM Options Mask Setting");
                printf("\n   57) Performance Management Parameter Configuration");
                printf("\n   58) Trigger PM Failures");
                printf("\n   59) Bitloading Per Tone");
#ifdef  BME_CPE_20

            printf ("\n   61) Configure BME memory");
            printf ("\n   62) GPIO Test");
#endif
                printf("\n   70) Maintenance Mode");
            }
            printf ("\n   90) BME Firmware versions");

            printf ("\n   99) Log off");
#ifndef PRODUCTION_CODE
            printf ("\n  101) Start line 1 in 3 bands mode");
#endif
            if (UserMode==SUPERVISOR_MODE)
            {
                printf ("\n  114) Clear Performance Counters");
                printf ("\n  121) Modify Auto Boot Timeout");
                printf ("\n  131) VDSL CRC Threshold");
                printf ("\n  140) Internal EOC Commands");
                printf ("\n  141) Overhead Message Commands");
                printf ("\n  143) Remote Ethernet Status Report");
                printf ("\n  150) Bit Swap Commands");
            }
#ifdef CO_30_DIAGS
            IK_PRINTF ("\n  210) Change diags power-on option\n");
#endif
            IK_PRINTF ("\n  212) Display All Performance Counters\n");
            printf ("\n");

            displayMenu = 0;
        }

        printf(PROMPT);
        //scanf("%s",pTlStr);
        gets (pTlStr);
        if ((pTlStr[0]=='\n') || (pTlStr[0]=='\0')) printf(PROMPT);
        if (PasswordVerified)
        {
#endif	//NOT ALASKA
            int host_reset_count = 0;

            /* Reset password timer */
            ConsoleTimer=CONSOLE_TIMEOUT;

            for (i=1; i <= MAX_NUM_OF_BMES; i++) {
              if (HostResync [i])
                host_reset_count ++;
            }
#ifdef ALASKA
   msgrcv(mq_id, &vdsl_msg, sizeof(vdsl_msg), 0, 0);
   if(vdsl_msg.webflag)
   {
     webflag = 1;
   vdslout = fopen("/tmp/vdslcmd.out","w");
   fclose(vdslout);
   }
   else
   webflag=0;
   switch(vdsl_msg.mtype)
   {
     case 2:    //BME Reset
        oampBmeStateReset(1);
        sprintf(pTlStr,"breset:0:1;");
        HostReset = 0;
        HostResync [1] = 0;
        hard_start = 1;
        break;

     case 3:    //system provision
        if (oampGetUtopiaMode == 0x80 || oampGetUtopiaMode == 0x91)
          pktMode = 128;  //PTM Mode
        else if(oampGetUtopiaMode == 0xc0 || oampGetUtopiaMode == 0xc1)
          pktMode = 0xc0; //EFM Mode
        else
          pktMode = 0;    //ATM Mode
        bmeBandPlan = getBmeBandPlan (oampGetBandPlan);
        sprintf(pTlStr,"sysprov:0:1:33:55:17185:1:%i:53:0:%d:%d;",pktMode, bmeBandPlan, IPOS_MAX_PORTS / IPOS_MAX_BME);
        if (oampGetBmeState(1) == uIDLE)
        {
          setPortMap(1, bmeBandPlan);
          printf("\nsetPortMap called\n");
        }
        break;

     case 4:
        if(getBmePortId_local(&Pid) == 0)
        {
          sprintf (pTlStr,"pprov:0:1:1:2;");
        }
        else
          pTlStr[0] = '\0';
        break;

     case 5:    //port start
        if(getBmePortId_local(&Pid) == 0)
        {
          portState = oampBme[1].oampPort[1].portState;
          if (portState==uSHOWTIME || portState==uACTIVATING ||
              portState==uLOOPBACK)
          {
              if(webflag)
              {
              vdslout = fopen("/tmp/vdslcmd.out","a");
              fprintf (vdslout,"\nPORT_START fail: Port is not in idle state");
              fclose(vdslout);
              }
              else
              {
              printf ("\nPORT_START fail: Port is not in idle state\n");
              }
              pTlStr[0] = '\0';
          }
          else
          {
            sprintf(pTlStr,"pstart:0:1:1;");
            autoStart=1;
          }
        }
        else
          pTlStr[0] = '\0';
        break;

     case 7: //Port stop
       if(getBmePortId_local(&Pid) == 0)
        {
          sprintf (pTlStr,"pstop:0:1:1;");
          autoStart=0;
        }
        else
          pTlStr[0] = '\0';
        break;

     case 9:    //Loopback Test
        if(getBmePortId_local(&Pid) == 0)
        {
          if(oampBme[1].oampPort[1].portState == uENABLE)
          {
            int lbType;
            if(strcasecmp(vdsl_msg.mtext,"utopia")==0)
              lbType = 1;
            else
              lbType = 2;
            sprintf(pTlStr,"lpbk:0:1:1:%i;",lbType);
          }
          else
          {
               if(webflag)
               {
               vdslout = fopen("/tmp/vdslcmd.out","w");
               fprintf(vdslout,"Port 1 is not in idle state.");
               fclose(vdslout);
               }
               else
               printf("Port 1 is not in idle state.\n");
               pTlStr[0] = '\0';
          }
        }
        else
          pTlStr[0] = '\0';
        break;

     case 16:   //clear User Logs
        sprintf (pTlStr,"logc:0;");
        break;

     case 58:
        if(getBmePortId_local(&Pid) == 0)
        {
          memcpy((unsigned char *)&PmTrigger, vdsl_msg.mtext, sizeof(PmTrigger));
          sprintf (pTlStr,"pmtrigger:0:1:1;");
        }
        else
          pTlStr[0] = '\0';
        break;

     case 114:  //clear performance counters
        if(getBmePortId_local(&Pid) == 0)
        {
          portState = oampBme[1].oampPort[1].portState;
          if((portState == uSHOWTIME)||(portState == uLOOPBACK))
          {
            sprintf (pTlStr,"clrcntr:0:1:1;");
            getLineNum( Pid, &linenum ); //check the declaration of linenum
            getIniPhy( linenum, &ptmfIndex ); // --Do-- ptmfIndex
            iposPtmfSetCounter( ptmfIndex, ALL_COUNTERS, 0);
          }
          else
          {
           printf("\nPort 1 is not in showtime.");
            pTlStr[0] = '\0';
          }
        }
        else
          pTlStr[0] = '\0';
        break;

     case 10:   //request brief port status
        if(getBmePortId_local(&Pid) == 0)
          sprintf (pTlStr,"pstat:0:1:1;");
        else
          pTlStr[0] = '\0';
        break;

     case 11:   //request extended port status
        if(getBmePortId_local(&Pid) == 0)
        {
          portState = oampBme[1].oampPort[1].portState;
          if(portState == uSHOWTIME)
          {
            sprintf (pTlStr,"pstatex:0:1:1;");
          }
          else
          {
            printf("\nPort 1 is not in showtime.");
            pTlStr[0] = '\0';
          }
        }
        else
          pTlStr[0] = '\0';
        break;

     case 12:   //Display Performance (PM) counters
        if(getBmePortId_local(&Pid) == 0)
        {
          if(!(oampGetOamOptionMask & 0x1))
          {
            printf ("\nPerformance Counters for Port 1\n");
            displayPerfCntrs(Pid);
          }
          else
          {
            printf ("\nPM Counters for Port 1\n");
            Pid.bmeNum = 1;
            Pid.portNum= 1;
            displayPmCounters(Pid);
          }
        }
        pTlStr[0] = '\0';
        break;

     case 13:   //Get Near End SNR Margin
        if(getBmePortId_local(&Pid) == 0)
        {
          portState = oampBme[1].oampPort[1].portState;
          if(portState == uSHOWTIME)
          {
            sprintf (pTlStr,"getsnr:0:1:1;");
          }
          else
          {
            printf("\nPort 1 is not in showtime\n");
            pTlStr[0] = '\0';
          }
        }
        else
          pTlStr[0] = '\0';
        break;

     case 15:   //Display user logs
        sprintf (pTlStr,"logp:0;");
        break;

     case 90:   //Display BME versions
        sprintf(pTlStr,"devver:0:1;");
        break;

     case 42:
        uiElmProcess((char *)vdsl_msg.mtext);
        pTlStr[0] = '\0';
        break;

     case 141:
        if(getBmePortId_local(&Pid) == 0)
        {
          portState = oampBme[1].oampPort[1].portState;
          if(portState == uSHOWTIME)
          {
            ohmCmdProcess(Pid,&vdsl_msg.mtext[0]);
          }
          else
            printf ("\nPort 1 is not in showtime.");
        }
        pTlStr[0] = '\0';
        break;

     default:
        printf("\nUNKNOWN COAMMAND - type: %d\n",vdsl_msg.mtype);
        pTlStr[0] = '\0';
        break;
   }

#else
            /* Allow selected commands, when the Host Hot Reset is in progress */

            if ((host_reset_count > 0) && (atoi(pTlStr) != 1) && (atoi(pTlStr) != 20) && (atoi(pTlStr) != 0)) {

              printf ("Cannot execute this command when the Host is in HOT_RESET mode.\n");
              printf ("Please use command 1 to resync with BME.\n");
              pTlStr[0] = '\0';

            } else  if ((pTlStr[0] != '?') && (strlen(pTlStr) > 0) && (strlen(pTlStr) <= 4)) {

                switch (atoi(pTlStr))
                {
                    case 1:
                     {
                         char temparr[10];  

                         if (UserMode==SUPERVISOR_MODE)
                         {
                             if (host_reset_count == 0) {
                               printf ("\nReset Host : Are you sure(y/n)? ");
                               gets(temparr);
                               sscanf (temparr,"%c",&resetConfirm);
                             } else {
                              resetConfirm = 'y';
                             }
  
                             if ((resetConfirm=='y') || (resetConfirm=='Y'))
                             {
  
                               host_reset_count = 0;

                               for (i=1; i <= MAX_NUM_OF_BMES; i++) {
  
                                 /* Check if the BME is running */
                                 /* printf("Checking whether the BME is operational\n"); */
  
                                 for (idle_counter_check = 0; idle_counter_check < 2; idle_counter_check++) {
  
                                   /* printf("Curr Val is %d\n",curr_val); */
                                   bmePioRead(&BmeStruct[i], HOST_DBG_API_HB2, (BYTE *) &curr_val);
    
                                   /* printf("Current IDLE Counter value is %d\n",curr_val); */
                                   if (idle_counter_check == 0) {
                                     prev_val = curr_val;   
                                     iposTaskDelay(2 * CLOCKS_PER_SEC);
                                   }
                                   else {
                                    if (prev_val != curr_val) {  
                                        printf("BME-%d is operational. ", i);  
                                        host_reset_count ++;
                                        HostReset = 1;
                                        HostResync [i] = 1;
                                        oampBmeStateReset(i);
                                        resetConfirm = 0;
                                     }  else {
                                         printf("BME-%d is not running. ", i);
                                         HostResync [i] = 0;
                                         pTlStr[0] = '\0';
                                         break;
                                     }
                                   }
                                 }
                               }

                               if (host_reset_count > 0) {

                                 printf("\nDo you want to Sync with the BME(s) (y/n) ? ");
                                 gets(temparr);
                                 sscanf(temparr,"%c", &resetConfirm);
                                 if ((resetConfirm=='y') || (resetConfirm=='Y')) {
                                   HostReset = 0;
                                   /* Rsync all the BMEs */
                                   sprintf(pTlStr,"hostreset:0;\n");
                                 } else {
                                   pTlStr[0] = '\0';
                                 }
                               }
                             } else {
                               pTlStr[0] = '\0';
                             }
                           }
                       }
                    break;

                    case 2:
                        if (UserMode==SUPERVISOR_MODE)
                        {

                            if (MAX_NUM_OF_BMES > 1)
                            {
                                char TempArray[20];
                                printf ("Enter bme number: ");
                                scanf ("%i",&bmenum);
                                gets(TempArray);
                            } else
                            {
                                bmenum=1;
                            }

                            printf ("\nRe-start BME #%d: Are you sure(y/n)? ",bmenum);
                            scanf ("%c",&resetConfirm);

                            printf ("\n%c ",resetConfirm);

                            if ((resetConfirm=='y') || (resetConfirm=='Y'))
                            {
                                oampBmeStateReset(bmenum);
                                sprintf(pTlStr,"breset:0:%i;",bmenum);
                                HostReset = 0;
                                HostResync [bmenum] = 0;
                            } else
                            {
                                printf ("\n%d ",resetConfirm);
                                pTlStr[0] = '\0';
                            }

                        }
                        break;

                    case 3:
                        if (UserMode==SUPERVISOR_MODE)
                        {
                            if (MAX_NUM_OF_BMES >1)
                            {
                                char TempArray[20];
                                printf ("Enter bme number: ");
                                scanf ("%i",&bmenum);
                                gets(TempArray);
                            } else
                            {
                                bmenum=1;
                            }
                            if ((bmenum <= 0) || (bmenum > MAX_NUM_OF_BMES))
                            {
                              printf("Invalid BME number %d\n", bmenum);
                              pTlStr[0] = '\0';
                            }
                            else
                            {
                              BandPlan = getBandPlan (oampGetBandPlan);
                              bmeBandPlan = getBmeBandPlan (BandPlan);


                              if (oampGetUtopiaMode == 0x80 || oampGetUtopiaMode == 0x81)
                                  pktMode = 128;      // PTM mode
                              else if(oampGetUtopiaMode == 0xc0 || oampGetUtopiaMode == 0xc1)
                                  pktMode = 0xc0;      // EFM mode
                              else
                                  pktMode = 0;        // ATM mode


                              sprintf(pTlStr,"sysprov:0:%i:33:55:17185:1:%i:53:0:%d:%d;",bmenum, pktMode, bmeBandPlan, IPOS_MAX_PORTS / IPOS_MAX_BME);

                              oampSetBandPlan(BandPlan);
                              if (oampGetBmeState(bmenum) == uIDLE)
                                setPortMap(bmenum, bmeBandPlan);            /* set the port mapping */
                            }
                        }  // Supervisor mode

                        break;

                    case 4:
                        if (UserMode==SUPERVISOR_MODE)
                        {
                            if (getPortNum(&Pid) > 0)
                {
                getLineNum (Pid, &lineNum);
                profilenum=ProfileMapping[lineNum];
                                sprintf (pTlStr,"pprov:0:%i:%i:%i;", Pid.bmeNum, Pid.portNum, profilenum);
                }
                            else
                                pTlStr[0] = '\0';
                        }
                        break;

                    case 5:
                        if (UserMode==SUPERVISOR_MODE)
                        {
                            if (getPortNum(&Pid) > 0)
                            {

                                portState=oampGetPortState(Pid);

                                if (portState==uSHOWTIME || 
                                    portState==uACTIVATING ||
                                    portState==uLOOPBACK)
                                {
                                    printf ("\nPORT_START fail: Port is not in idle state");
                                    pTlStr[0] = '\0';
                                } else
                                {
                                    sprintf(pTlStr,"pstart:0:%i:%i;",Pid.bmeNum,Pid.portNum);
                                }
                            } else
                                pTlStr[0] = '\0';
                        }
                        break;

                    case 6:
                        if (UserMode==SUPERVISOR_MODE)
                        {
                            if (getPortNum(&Pid) > 0)
                                sprintf (pTlStr,"preset:0:%i:%i:0;",Pid.bmeNum,Pid.portNum);
                            else
                                pTlStr[0] = '\0';
                        }
                        break;

                    case 7:
                        if (UserMode==SUPERVISOR_MODE)
                        {
                            if (getPortNum(&Pid) > 0)
                                sprintf (pTlStr,"pstop:0:%i:%i;",Pid.bmeNum,Pid.portNum);
                            else
                                pTlStr[0] = '\0';
                        }
                        break;
#ifdef VTU_O
                    case 8:
                        if (UserMode==SUPERVISOR_MODE)
                        {
                            if (getPortNum(&Pid) > 0)
                            {

                                portState=oampGetPortState(Pid);

                                if (portState==uSHOWTIME||portState==uACTIVATING)
                                {
                                    printf ("\nPORT_INSTANTIATE fail: Port is not in idle state");
                                    pTlStr[0] = '\0';
                                } else
                                {
                                    sprintf(pTlStr,"pinst:0:%i:%i;",Pid.bmeNum,Pid.portNum);
                                }
                            } else
                                pTlStr[0] = '\0';
                        }
                        break;
#endif
                    case 9:
                        if (UserMode==SUPERVISOR_MODE)
                        {
                            if (getPortNum(&Pid) > 0)
                            {
                                if ( (portState=oampGetPortState(Pid)) == uENABLE )
                                {
                                int lbType;

                                    printf("\nEnter Loopback test type: (1: Utopia  2: AFE)");
                                    scanf("%d", &lbType);

                                sprintf(pTlStr,"lpbk:0:%i:%i:%i;",Pid.bmeNum,Pid.portNum,lbType);
                                }
                                else
                                {
                                    printf("Port %d is not in idle state.", portnum);
                                    pTlStr[0] = '\0'; 
                                }

                            } else
                                pTlStr[0] = '\0';
                        }
                        break;
                    case 10:
                        if (getPortNum(&Pid) > 0)
                            sprintf (pTlStr,"pstat:0:%i:%i;",Pid.bmeNum,Pid.portNum);
                        else
                            pTlStr[0] = '\0';
                        break;

                    case 11:
                        if ((portnum = getPortNum(&Pid)) > 0)
                        {
                            if (oampGetPortState(Pid)==uSHOWTIME)
                                sprintf (pTlStr,"pstatex:0:%i:%i;",Pid.bmeNum,Pid.portNum);
                            else
                            {
                                printf("\nPort %d is not in showtime.", portnum);
                                pTlStr[0] = '\0';
                            }
                        } else
                            pTlStr[0] = '\0';
                        break;

                    case 12:
                        if ((portnum = getPortNum(&Pid)) > 0)
                        {
                if(!(oampGetOamOptionMask & 0x1))
                {
                    printf ("\nPerformance Counters for Port %d:", portnum);
                    displayPerfCntrs(Pid);
                }
                else
                {
                    printf ("\nPM Counters for Port %d:", portnum);
                    displayPmCounters(Pid);
                }

                        }
                        pTlStr[0] = '\0';
                        break;

                case 212:
                    if ((portnum = getPortNum (&Pid)) > 0)
                    {
                            // Check OamOptionMask value
                            if (oampGetOamOptionMask & 0x1)
                            {
                                IK_PRINTF ("\nPM Counters for Port %d:", portnum);
                                displayAllPmCounters (Pid);
                            }
                            else
                            {
                                IK_PRINTF ("\nPM mode is no enabled for Port %d:", portnum);
                            }
                    }
                    pTlStr[0] = '\0';
                    break;

                    case 13:
                        if ((portnum = getPortNum(&Pid)) > 0)
                        {
                            if (oampGetPortState(Pid)==uSHOWTIME)
                                sprintf (pTlStr,"getsnr:0:%i:%i;", Pid.bmeNum,Pid.portNum);
                            else
                            {
                                printf("\nPort %d is not in showtime.", portnum);
                                pTlStr[0] = '\0';
                            }
                        } else
                            pTlStr[0] = '\0';
                        break;

#ifdef VTU_O
                    case 14:
                        if (getPortNum(&Pid) > 0)
                            appEocFeCntr(Pid);
                        pTlStr[0] = '\0';
                        break;
#endif
                    case 15:
                        sprintf (pTlStr,"logp:0;");
                        break;
                    case 16:
                        sprintf (pTlStr,"logc:0;");
                        break;
#ifdef VTU_O
                    case 17:
                        if (getPortNum(&Pid) > 0)
                            appEocFeSnrAttn(Pid);
                        pTlStr[0] = '\0';
                        break;
#endif
            case 19:
                        if (getPortNum(&Pid) > 0)
            {
                U8  parm = 0;
                char    tmpArray[ 20 ];

                printf( "Enter 'y' to enable update reports: " );
                gets( &tmpArray[ 0 ] );
                if (tmpArray[ 0 ] == 'y' || tmpArray[ 0 ] == 'Y')
                  parm = 1;

                oampSetupPhaseChange( &Pid );
                iposUpdatedReportEnable( Pid, parm, 0, 0, updatedReportsCb );
            }
                        pTlStr[0] = '\0';
                        break;

                    case 21:
                        if (UserMode==SUPERVISOR_MODE)
                        {
                            if (setPortProfile(pTlStr)== UPDATE_IN_FLASH)  //Changes made to the parameters' values
                            {
                                printf("\n Writing the data into Flash");
                                updateFlashProf();
                            }
                        }
                        pTlStr[0] = '\0';
                        break;

                    case 22:
                        if (UserMode==SUPERVISOR_MODE)
                            changePassword();
                        pTlStr[0] = '\0';
                        break;
                    case 23:
            if (UserMode==SUPERVISOR_MODE)
            {
            printf ("\nPort to Profile Mapping");
            printf ("\n=======================");
            for (i=1;i<IPOS_MAX_PORTS+1;i++)
            printf ("\nPort: %i    Profile: %i",i,ProfileMapping[i]);
            printf ("\n");

            printf ("\nEnter port number: ");
            scanf ("%i",&i);
            printf ("Enter profile number: ");
            scanf ("%i",&profnum);

            if (i>IPOS_MAX_PORT_PER_BME) printf ("\nInvalid port number");
            else if (profnum>=MAX_PORT_PROFILES) printf ("\nInvalid profile number");
            else
              {
              ProfileMapping [i]=profnum;
              updateFlashProf();
              }

                        pTlStr[0] = '\0';
            }
                        break;
#ifndef CPE_40
                    case 24:
                        if (UserMode==SUPERVISOR_MODE)
                        {
                            i = oampGetUtopiaMode;
#ifdef CO_20
                            if (i== 0x81)
                                i = 2;
                            else if (i == 0x80)
                                i = 3;
#else                           
                            if (i == 0xc1)
                                i = 5;
                            else if (i == 0xc0)
                                i = 3;
                            else if (i== 0x81)
                                i = 4;
                            else if (i == 0x80)
                              i = 2;
#endif                          
                            else
                                i = 1;

              printf ("Enter selection(1: ATM; 2: PTM; 3: EFM) [%d]: ", i );
                            scanf ("%i",&i);

                            if (i == 1)
                            {
                                oampSetUtopiaMode(0);
                            } else if (i == 2)
#ifdef CO_20
                            {
                                oampSetUtopiaMode(0x81);   // PTM Mode Low Latency Mode - No 0x7E insertion
                            } else if (i == 3)
                            {
                                oampSetUtopiaMode(0x80);
                                printf("PTMF inserts 0x7E!\n");
                            }
#else
                            {
                                oampSetUtopiaMode(0x80);
                            } 
                            else if (i == 3)
                            {
                                oampSetUtopiaMode(0xc0);   // EFM Framing
                            } else if (i == 4)
                            {
                                oampSetUtopiaMode(0x81);   // PTM Mode Low Latency Mode
                                printf("Incorrect value entered\n");
                            } 
                            else  if (i == 5)
                            {
                                oampSetUtopiaMode(0xc1);   // EFM Low Latency Mode
                                printf("Incorrect value entered\n");
                            } 
#endif
                            else
                                printf("Incorrect value entered\n");
                        }
                        pTlStr[0] = '\0';

                        break;
#endif
                    case 25:
                        if (UserMode==SUPERVISOR_MODE)
                        {
                            printf (" Configure system provision options \n");


                            i=(oampGetOptionMask&0x8)>>3;

#ifdef VTU_O
              printf ("Enter UPBO (1-UPBO Enable / 0-UPBO Disable) [%d]: ",
                                    (oampGetOptionMask&0x8)>>3  );
              scanf ("%i",&i);

              if (i == 0)
              {
                                oampSetOptionMask(oampGetOptionMask&0xf7);
              }
              else
              {
                                oampSetOptionMask(oampGetOptionMask|0x8);
                                if (i == 1)
                  oampSetK_array(k0, k1, k0_hi, k1_hi);
                else
                {
                                    if (i == 2)
                    getCO_PSD_const_array();
                                }
                            }
#elif defined(VTU_R)
                            printf ("Enter UPBO Weak Mode (1-Enable / 0-Disable) [%d]: ",
                                    (oampGetOptionMask&0x20)>>5  );
              scanf ("%i",&i);

              if (i == 0)
        {
                                oampSetOptionMask(oampGetOptionMask&0xdf);
        }
              else
        {
                                oampSetOptionMask(oampGetOptionMask|0x20);
        }
              oampSetK_array(k0, k1, k0_hi, k1_hi);
#endif


                            psdMaskLevelIndex = getPsdMaskLevel(oampGetPsdIndex);

                        // Read Maximum PSD Levels from user
                        getMaxPsd();

                        printf ("Enter ADSL Safe Mode (1-Enable / 0-Disable) [%d]: ",
                                    (oampGetOptionMask&ADSL_SAFE_MODE)>>6  );
              scanf ("%i",&i);

              if (i == 0)
                            {
                                oampSetOptionMask(oampGetOptionMask&(~ADSL_SAFE_MODE));
                            }
              else
                            {
                                oampSetOptionMask(oampGetOptionMask|ADSL_SAFE_MODE);
                            }
                        }
                        pTlStr[0] = '\0';
                        break;
                    case 126:
                        printf(" Current PSD Mask Level : %d", oampGetPsdIndex);
                        pTlStr[0] = '\0';
                        break;
#ifdef VTU_O
                    case 127:
                        oampPrintK_array();
                        pTlStr[0] = '\0';
                        break;
#endif

#ifdef INI_SUPPORT
                    case 30:
                        printf ("Enter Option (0-Allow /1-Block Bad Frame) [%d]:",dropFrameEnable);
                        scanf ("%i",&i);

                        if (i==0)
                            dropFrameEnable = 0;
                        else
                            dropFrameEnable = 1;

                        pTlStr[0] = '\0';
                        break;
#endif //INI_SUPPORT
                    case 31:
                        if (UserMode==SUPERVISOR_MODE)
                        {
                            printf ("Enter INI CRC Threshold in unit of 10**-4 (1..10000) [%d]: ",
                                    oampGetIniCrcThreshold);
                            scanf ("%i",&i);
                            if ((i > 0) && (i <= 10000))
                            {
                                if (i != (int)oampGetIniCrcThreshold)
                                {
                                    oampSetIniCrcThreshold(i);
                                    numCrcCheckFrames = 300000/i;
                                }
                            } else
                                printf("Incorrect value entered\n");
                        }
                        pTlStr[0] = '\0';
                        break;
#ifdef INI_SUPPORT
                    case 32:
                        if (UserMode==SUPERVISOR_MODE)
            {
#if defined (P2CO) && defined (VTU_R)
              printf("This option is not Supported\n");
                          pTlStr[0] = '\0';
                         break;
#endif //defined (P2CO) && defined (VTU_R)
                            MacFilterMenu();
            }
                        pTlStr[0] = '\0';

                        break;
#endif //INI_SUPPORT
                    case 33:
                        printf ("Pause Frame Generation (0-OFF /1-ON) [%d]: ", oampGetEnetFlowControl);
                        scanf ("%i",&i);

                        if (i < 2)
                        {
                            oampSetEnetFlowControl(i);
                        } else
                            printf("Incorrect selection\n");

                        pTlStr[0] = '\0';
                        break;

#ifdef VTU_O
                    case 40:
                        if (UserMode==SUPERVISOR_MODE)
                        {
                            if (getPortNum(&Pid) > 0)
                                appEocLbReq(Pid);
                        }
                        pTlStr[0] = '\0';
                        break;
#endif

/* For EOC loopback testing */

                      case 41:
                        if (UserMode==SUPERVISOR_MODE)
                        {                               /* For CPE (VTU_R) this only works */
                            uiEocLbStressMenu();        /* with error counts for the ports */
                        }
                        pTlStr[0] = '\0';
                        break;

                      case 42:
            if (UserMode==SUPERVISOR_MODE)
            {
                uiElmMenu();    /* do not let the operator get BME event logs */
            }
            pTlStr[0] = '\0';

            break;

                      case 43:
            if (UserMode==SUPERVISOR_MODE)
            {
                uiRMMMenu();    /* do not let the operator access RMM ... (TT ID 1311) */
            }
            pTlStr[0] = '\0';

            break;

#ifdef  USE_RFM
#ifdef  VTU_O
                    case    50:
            if (UserMode==SUPERVISOR_MODE)
            {
                            RFMMenu();      /* do not let the operator access RFM ... (TT ID 831) */
            }
            pTlStr[0] = '\0';
                        break;

#endif
#endif
                    case 51:
                        if (UserMode == SUPERVISOR_MODE && func1 != NULL)
                            func1();
                        pTlStr[0] = '\0';
                        break;
                    case 52:
                        if (UserMode == SUPERVISOR_MODE && func2 != NULL)
                            func2();
                        pTlStr[0] = '\0';
                        break;
                    case 54:
                        printf(" enter customer ID [%d]: ",  oampGetCustID());
                        scanf("%d", &customerID);
                        oampSetCustID(customerID);
                        printf(" enter keys [%d %d %d]:  ",  oampGetKeys(0), oampGetKeys(1), oampGetKeys(2));
                        scanf("%d %d %d", &key1, &key2, &key3);
                        oampSetAllKeys(key1, key2, key3);
                        pTlStr[0] = '\0';
                        break;
                    case 55:
                        brd_cfg();
                        pTlStr[0] = '\0';
                        break;
                    case 56:
                     {
                        U8 mask = 0;

                        printf("\n\tOamOptionMask Configuration");

                        printf("\n\nEnter PM Counters Report Option (0-Disable / 1-Enable)  [%d]: ",
                                oampGetOamOptionMask & 0x1);
                        scanf("%d", &i);
                        if (i == 0) {
                          mask &= ~(0x1);
                          printf ("PM Counters Option Disabled");
                        } else {
                          mask |= 0x1;
                          printf ("PM Counters Option Enabled");
                        }

                        printf("\n\nEnter Alert Message Enable Option (0-Disable / 1-Enable) [%d]: ",
                               (oampGetOamOptionMask >> 1) & 0x1);
                        scanf("%d", &i);
                        if (i == 0) {
                          mask &= ~(0x2);
                          printf ("Alert Message Option Disabled");
                        } else {
                          mask |= (0x3);
                          printf ("PM Counters Option and Alert Message Option Enabled");
                        }

                        printf("\n\nEnter Bit Swap Disable Option (0-Enable / 1-Disable) [%d]: ",
                               (oampGetOamOptionMask >> 7) & 0x1);
                        scanf("%d", &i);
                        if (i == 0) {
                          mask &= ~(0x80);
                          printf ("Bit Swap is Enabled");
                        } else {
                          mask |= (0x80);
                          printf ("Bit Swap is Disabled");
                        }
                        oampSetOamOptionMask(mask);

                        printf ("\n\nOamOptionMask Set to %x", oampGetOamOptionMask);
                        
                                pTlStr[0] = '\0';
                        
                        break;
                     }

                    case 57:
                        if (UserMode==SUPERVISOR_MODE)
                        {
                            printf ("\n\nPerformance Management Parameter Configuration\n");
                            
                            if (getPortNum(&Pid) > 0)
                            {
                                printf ("\nDefault Values Chosen\n");
                                sprintf (pTlStr,"pmconfig:0:%i:%i;", Pid.bmeNum, Pid.portNum);

                            } else {
                                pTlStr[0] = '\0';
                            }

                        } else 
                                   pTlStr[0] = '\0';
                        
                        break;

                    case 58:
                        if (UserMode==SUPERVISOR_MODE)
                        {
                            printf ("\n\nTrigger PM Failures\n");
                            
                            if (getPortNum(&Pid) > 0)
                            {
                                printf ("\nEnter Trigger-Word for Near-End Failures (in U16 Hex) [%hx] :",
                                         PmTrigger.NeFailures );
                                scanf ("%hx", &PmTrigger.NeFailures);

                                printf ("\nEnter Trigger-Word for Far-End Failures (in U16 Hex) [%hx] :",
                                         PmTrigger.FeFailures );
                                scanf ("%hx", &PmTrigger.FeFailures);

                                printf ("\nEnter Trigger-Word for Near-End TCA1 (in U16 Hex) [%hx] :",
                                         PmTrigger.NeTCA1);
                                scanf ("%hx", &PmTrigger.NeTCA1);

                                printf ("\nEnter Trigger-Word for Far-End TCA1 (in U16 Hex) [%hx] :",
                                         PmTrigger.FeTCA1);
                                scanf ("%hx", &PmTrigger.FeTCA1);

                                printf ("\nEnter Trigger-Word for Near-End TCA2 (in U16 Hex) [%hx] :",
                                         PmTrigger.NeTCA2);
                                scanf ("%hx", &PmTrigger.NeTCA2);

                                printf ("\nEnter Trigger-Word for Far-End TCA2 (in U16 Hex) [%hx] :",
                                         PmTrigger.FeTCA2);
                                scanf ("%hx", &PmTrigger.FeTCA2);


                                printf ("\nNeFailures = 0x%hx\nFeFailures = 0x%hx",
                                        PmTrigger.NeFailures, PmTrigger.FeFailures);
                                printf ("\nNeTCA1 = 0x%hx\nFeTCA1 = 0x%hx",
                                        PmTrigger.NeTCA1, PmTrigger.FeTCA1);
                                printf ("\nNeTCA2 = 0x%hx\nFeTCA2 = 0x%hx",
                                        PmTrigger.NeTCA2, PmTrigger.FeTCA2);


                                sprintf (pTlStr,"pmtrigger:0:%i:%i;",Pid.bmeNum,Pid.portNum);

                            } else
                                pTlStr[0] = '\0';

                        } else 
                                   pTlStr[0] = '\0';
                        
                        break;
                         case 59:
                        if (UserMode==SUPERVISOR_MODE)
                           perToneMenu();
                           pTlStr[0] = '\0';
                        break;

                        case 70:
                            if (UserMode==SUPERVISOR_MODE)
                            {
                                if ( getPortNum(&Pid) > 0 )
                                {
                                 ipos_test_signals testSignals;
                                 int retStatus;

                                    retStatus = uiMaintenanceMenu (&testSignals);
                                    if (retStatus > 0 )
                                    {
                                        if ( retStatus == 1 )
                                        {
                                            sprintf(pTlStr,"sendsig:0:%i:%i:%i:%i:%i:%i:%i:%i;",
                                                      Pid.bmeNum,Pid.portNum, testSignals.SigType,testSignals.NumTones,
                                                      testSignals.Tone1, testSignals.Tone2, testSignals.Tone3,
                                         testSignals.SweepInterval);
                                        }
                                        else if ( retStatus == 2 )
                                        {
                                            sprintf(pTlStr,"detectsig:0:%i:%i:%i:%i:%i:%i:%i:%i;",
                                                      Pid.bmeNum,Pid.portNum, testSignals.SigType,testSignals.NumTones,
                                                      testSignals.Tone1, testSignals.Tone2, testSignals.Tone3,
                                         testSignals.SweepInterval);
                              }
                                        else if ( retStatus == 3 )
                                        {
                                            sprintf (pTlStr,"pstop:0:%i:%i;",Pid.bmeNum,Pid.portNum);
                                        }
                                        else
                                            pTlStr[0] = '\0';
                                    }
                                    else
                                        pTlStr[0] = '\0';
                                }
                                else
                                    pTlStr[0] = '\0';
                            }
                            else
                                pTlStr[0] = '\0';
                            break;
#ifdef VTU_O
#if 0
                    case 80:
                        if (UserMode==SUPERVISOR_MODE)
                        {
                            if (download_cpe_code()== ERROR)
                            {
                                printf("\n Error !!. File Download Failed");
                            } else
                                printf("\n File Download Successfully completed");


                            pTlStr[0] = '\0';
                        }
                        break;

                    case 81:
                        if (UserMode==SUPERVISOR_MODE)
                        {
                            printf ("Enter dest BmeNum: ");
                            scanf ("%i",&dBmeNum);
                            printf ("Enter dest PortNum: ");
                            scanf ("%i",&dPortNum);
                            Pid.BmeNum=dBmeNum;
                            Pid.PortNum=dPortNum;

                            SendMail (CPE_DOWNLOAD,Pid,UiTask,PortTask, 0, 0);
                        }
                        pTlStr[0] = '\0';
                        break;
#endif
#endif
                    case 90:
                        if (MAX_NUM_OF_BMES > 1)
                        {
                            printf ("Enter bme number: ");
                            scanf ("%i",&bmenum);
                        } else
                        {
                            bmenum = 1;
                        }
                        sprintf(pTlStr,"devver:0:%i;",bmenum);
                        break;

#ifdef  BME_CPE_20


                    case 61:

                        azMemMenu();

                        break;

                    case 62:
                      PrGpioTestMenu();
                        break;

#endif
                    case 99:
                    {

                        pTlStr[0] = '\0';
                        printf("\nLogged off from system");
                        PasswordVerified = 0;
                        ConsoleTimer = 0;
                        autoStart = 1;
//            pmEnable = 1;

                    }
                    break;


                    case 112:
#ifdef VTU_O
                        if ((portnum = getPortNum(&Pid)) > 0)
#endif
                        {
#ifndef VTU_O
                  portnum = 1;
                  getBmePortId(1, &Pid);
#endif
                            if(!(oampGetOamOptionMask & 0x1))
                        {
                            printf ("\nPM Counters for Port %d:", portnum);
                                printf ("\nFEC_F: %lu, CRC_F: %u, FEC_S: %lu, CRC_S: %u, LOS: %u SEF: %u",
                                        (oampBme[Pid.bmeNum].oampPort[Pid.portNum].Counters.NeFEC_F),
                                        (oampBme[Pid.bmeNum].oampPort[Pid.portNum].Counters.NeCRC_F),
                                        (oampBme[Pid.bmeNum].oampPort[Pid.portNum].Counters.NeFEC_S),
                                        (oampBme[Pid.bmeNum].oampPort[Pid.portNum].Counters.NeCRC_S),
                                        oampBme[Pid.bmeNum].oampPort[Pid.portNum].Counters.NeLOS,
                                        oampBme[Pid.bmeNum].oampPort[Pid.portNum].Counters.NeSEF);
                                printf ("\nTxBlkCnt_F: %lu, TxBlkCnt_S: %lu, RxBlkCnt_F: %lu, RxBlkCnt_S: %lu",
                                        (oampBme[Pid.bmeNum].oampPort[Pid.portNum].Counters.numTxBlk_F),
                                        (oampBme[Pid.bmeNum].oampPort[Pid.portNum].Counters.numTxBlk_S),
                                        (oampBme[Pid.bmeNum].oampPort[Pid.portNum].Counters.numRxBlk_F),
                                        (oampBme[Pid.bmeNum].oampPort[Pid.portNum].Counters.numRxBlk_S));

                                printf ("\n NeFECUnCrr_S: %lu, NeFECUnCrr_F: %lu",
                                        (oampBme[Pid.bmeNum].oampPort[Pid.portNum].Counters.NeFECUnCrr_S),
                                        (oampBme[Pid.bmeNum].oampPort[Pid.portNum].Counters.NeFECUnCrr_F));

                                printf ("\nnumUsrCell_S: %lu, numUsrCell_F: %lu",
                                        (oampBme[Pid.bmeNum].oampPort[Pid.portNum].Counters.numUsrCell_S),
                                        (oampBme[Pid.bmeNum].oampPort[Pid.portNum].Counters.numUsrCell_F));

                                printf ("\nnumIdlCell_S: %lu numIdlCell_F: %lu",
                                        (oampBme[Pid.bmeNum].oampPort[Pid.portNum].Counters.numIdlCell_S),
                                        (oampBme[Pid.bmeNum].oampPort[Pid.portNum].Counters.numIdlCell_F));

                                printf ("\n\nNeNCD_S: %u, NeNCD_F: %u, NeOCD_S: %u, NeOCD_F: %u, NeHEC_S: %u, NeHEC_F: %u",
                                        (oampBme[Pid.bmeNum].oampPort[Pid.portNum].Counters.NeNCD_S),
                                        (oampBme[Pid.bmeNum].oampPort[Pid.portNum].Counters.NeNCD_F),
                                        (oampBme[Pid.bmeNum].oampPort[Pid.portNum].Counters.NeOCD_S),
                                        (oampBme[Pid.bmeNum].oampPort[Pid.portNum].Counters.NeOCD_F),
                                        (oampBme[Pid.bmeNum].oampPort[Pid.portNum].Counters.NeHEC_S),
                                        (oampBme[Pid.bmeNum].oampPort[Pid.portNum].Counters.NeHEC_F));
                            }
                            else
                            {
                                  ipos_pm_counters *pmCntrs;
                                  ipos_pm_counters *pm24hrs;
                                  ipos_pm_counters *pmStart;
                                
                                  pmCntrs = &(oampBme[Pid.bmeNum].oampPort[Pid.portNum].PmCounters);
                                  pmStart = &(oampBme[Pid.bmeNum].oampPort[Pid.portNum].PmCountersAtPortStart);
                                  pm24hrs = pPmCntr24Hrs[Pid.bmeNum][Pid.portNum];
 
                                printf ("\nFEC_F: %lu, CRC_F: %lu, FEC_S: %lu, CRC_S: %lu, LOS: %u SEF: %u",
                                    pm24hrs->NeFEC_F + pmCntrs->NeFEC_F - pmStart->NeFEC_F,
                                    pm24hrs->NeCRC_F + pmCntrs->NeCRC_F - pmStart->NeCRC_F,
                                    pm24hrs->NeFEC_S + pmCntrs->NeFEC_S - pmStart->NeFEC_S,
                                    pm24hrs->NeCRC_S + pmCntrs->NeCRC_S - pmStart->NeCRC_S,
                                    pm24hrs->NeLOS   + pmCntrs->NeLOS   - pmStart->NeLOS,
                                    pm24hrs->NeLOF   + pmCntrs->NeLOF   - pmStart->NeLOF);

                                printf ("\nTxBlkCnt_F: N/A, TxBlkCnt_S: N/A, RxBlkCnt_F: N/A, RxBlkCnt_S: N/A");

                                printf ("\nNeFECUnCrr_S: N/A, NeFECUnCrr_F: N/A");

                                printf ("\nnumUsrCell_S: %lu, numUsrCell_F: %lu",
                                    pm24hrs->numUSRcell_S  + pmCntrs->numUSRcell_S  - pmStart->numUSRcell_S,
                                    pm24hrs->numUSRcell_F  + pmCntrs->numUSRcell_F  - pmStart->numUSRcell_F);

                                printf ("\nnumIdlCell_S: %lu numIdlCell_F: %lu",
                                    pm24hrs->numIDLEcell_S + pmCntrs->numIDLEcell_S - pmStart->numIDLEcell_S,
                                    pm24hrs->numIDLEcell_F + pmCntrs->numIDLEcell_F - pmStart->numIDLEcell_F);

                                printf ("\nNCD_S: %u,    NCD_F: %u,    OCD_S: %u,    OCD_F: %u,    HEC_S: %lu,    HEC_F: %lu",
                                    pm24hrs->NeNCD_S + pmCntrs->NeNCD_S - pmStart->NeNCD_S,
                                    pm24hrs->NeNCD_F + pmCntrs->NeNCD_F - pmStart->NeNCD_F,
                                    pm24hrs->NeLCD_S + pmCntrs->NeLCD_S - pmStart->NeLCD_S,
                                    pm24hrs->NeLCD_F + pmCntrs->NeLCD_F - pmStart->NeLCD_F,
                                    pm24hrs->NeHEC_S + pmCntrs->NeHEC_S - pmStart->NeHEC_S,
                                    pm24hrs->NeHEC_F + pmCntrs->NeHEC_F - pmStart->NeHEC_F);
                            }
                    }
            pTlStr[0] = '\0';
            break;

                    case 121:
                        if (UserMode==SUPERVISOR_MODE)
                        {
                            printf ("Enter Auto Boot Timeout (0..100)s [%d]: ",
                                    oampGetAutoStartWaitTime);
                            scanf ("%i",&i);
                            if ((i >= 0) && (i <= 100))
                            {
                                if (i != oampGetAutoStartWaitTime)
                                    oampSetAutoStartWaitTime(i);
                            } else
                                printf("Incorrect value entered\n");
                        }
                        pTlStr[0] = '\0';
                                                break;
                case 114:      // Clear Near End Counters
                    if (UserMode == SUPERVISOR_MODE)
                    {

                        if ((portnum = getPortNum (&Pid)) > 0)
                        {
                                sprintf (pTlStr, "clrcntr:0:%i:%i;", Pid.bmeNum,
                                         Pid.portNum);

#ifdef INI_SUPPORT
                                getLineNum (Pid, &linenum);
                                getIniPhy (linenum, &ptmfIndex);
                                iposPtmfSetCounter (ptmfIndex, ALL_COUNTERS, 0);
#endif
                        }
                    }
                    break;

                case 115:
                    if (UserMode == SUPERVISOR_MODE)
                    {
                        if ((portnum = getPortNum (&Pid)) > 0)
                        {
                            sprintf(pTlStr, "getnetworkcntr:0:%i:%i;", Pid.bmeNum,Pid.portNum);
                        }
                    }
                    break;

                    case 131:
                        if (UserMode==SUPERVISOR_MODE)
                        {
                            printf ("Enter VDSL CRC Threshold in unit of 10**-8 (0..10000) [%d]: ",
                                    oampGetVdslCrcThreshold);
                            scanf ("%i",&i);
                            if ((i >= 0) && (i <= 10000))
                            {
                                if (i != (int)oampGetVdslCrcThreshold)
                                {
                                    ipos_port_id temp;
                                    temp.bmeNum  = 0;
                                    temp.portNum = 0;

                                    oampSetVdslCrcThreshold(i);
                                    reCalLineCrcThreshold(temp);
                                }
                            } else
                                printf("Incorrect value entered\n");
                        }
                        pTlStr[0] = '\0';
                                                break;

                      case 140:
                          if (UserMode == SUPERVISOR_MODE) {
                             if ((portnum = getPortNum(&Pid)) > 0) {
                            uiInternalEocMenu( Pid );     
                             }  
                          } 
                          pTlStr[0] = '\0';
                      break; 
                      
                case 141://OHM
                    if (UserMode == SUPERVISOR_MODE)
                    {
                        if ((portnum = getPortNum (&Pid)) > 0)
                        {

                            if (oampGetPortState (Pid) == uSHOWTIME)
                                uiOhmCmdMenu (Pid);
                            else 
                                printf ("\nPort %d is not in showtime.", portnum);
                        }
                    }
                    pTlStr[0] = '\0';
                    break;
                    case 143:
                        if (UserMode==SUPERVISOR_MODE)
                        {
                            printf ("Enter AutoEnetStatusRptFlag - Enable(1)/Disable(0) [%d]: ",
                                    oampGetRemEnetStatRptEn);
                            scanf ("%i",&i);
                            if ((i == 0) || (i = 1))
                            {
                                if (i != oampGetRemEnetStatRptEn)
                                {
                                    oampSetRemEnetStatusRptEn(i);
                                }
                            } else
                                printf("Incorrect value entered\n");
                        }
                        pTlStr[0] = '\0';
                        break;

                      case 150:
                          if (UserMode == SUPERVISOR_MODE) {
                             if ((portnum = getPortNum(&Pid)) > 0) {
                                if (oampGetPortState(Pid)==uSHOWTIME)
                              uiBitSwapMenu( Pid );   
                                else
                                {
                                  printf("\nPort %d is not in showtime.", portnum);
                                  pTlStr[0] = '\0';
                                }
                             }  
                          } 
                          pTlStr[0] = '\0';
                      break; 

                    case 678:
                        pTlStr[0] = '\0';
                        bmeDebugHandler ();
                        break;

#ifdef CO_30_DIAGS
                case 210:
                    printDiagOptions ();
                    pTlStr[0] = '\0';
                    break;
#endif
                case 231:
                    if (UserMode == SUPERVISOR_MODE)
                    {
                        IK_PRINTF ("Enter SixPtLineHoldEnable - Enable(1)/Disable(0) [%d]: ", getSixPtLineHoldEnable());

                        scanf ("%i", &i);

                        if ((i == 0) || (i = 1))
                        {
                            if (i != getSixPtLineHoldEnable())
                            {
                                setSixPtLineHoldEnable(i);
                            }
                        }
                        else
                            IK_PRINTF ("Incorrect value entered\n");
                    }
                    pTlStr[0] = '\0';

                    break;
#if defined(INI_SUPPORT) && !(defined(P2CPE))
                    case 679:
                       pTlStr[0] = '\0';
                       dbgIniMenu ();
                       break;
#endif


                    case 900:
                        pTlStr[0] = '\0';
                        doConsoleTimeOut = 0;
                        break;

                    case 901:
                        pTlStr[0] = '\0';
                        doConsoleTimeOut = 1;
                        break;
                    case 902:
#if 0
                        i = oampGetOptionMask;
                        TlanEn = (i & 0x10) >> 4;

                        printf ("Enter TLAN Enable (1=On)[%i]: ", TlanEn);
                        scanf ("%i",&TlanEn);

                        i = i & 0x2F;
                        if (TlanEn == 1)
                            i |= 0x10;
                        oampSetOptionMask(i);
                        pTlStr[0] = '\0';
#else
                        i = oampGetOptionMask;

                        printf ("Enter TLAN Enable (1=On)[%i]: ",(i&0x10)>>4);
                        scanf ("%i",&TlanEn);

                        if (TlanEn==0)
                        {
                            oampSetOptionMask(i&0xef);
                        }
                        else if (TlanEn==1)
                        {
                            j=(i|0x10);
                            printf("Enter SafeMode [%i]: ", (i&0x80)>>7);
                            scanf("%i", &safeMode);
                            if(safeMode)
                            {
                                oampSetOptionMask(j|0x80);
                            }
                            else
                            {
                                oampSetOptionMask(j&0x7f);
                            }
                        }

                        pTlStr[0] = '\0';
#endif
                        break;
          case 980:
                  printf ("\nRx task polling frequeny\n");
                  for (i=0;i<50;i++)
                    {
                    if (poll_index==i)
                    printf (" *%i ",pollFreq[i]);
                    else
                    printf (" %i ",pollFreq[i]);
                    }
                  printf("\n");
                  break;

                    case 990:
                        pTlStr[0] = '\0';
                        okToDumpLog = 0;
                        break;

                    case 991:
                        pTlStr[0] = '\0';
                        okToDumpLog = 1;
                        break;


                    case 992:
                        pTlStr[0] = '\0';
                        notResetBme = 1;        /* disable reset */
                        break;


                    case 993:
                        pTlStr[0] = '\0';
                        notResetBme = 0;        /* enable reset */
                        break;



                    case 997:
                        pTlStr[0] = '\0';
                        dumpAllBmeStatus();
                        break;

                    case 998:
                        pTlStr[0] = '\0';
                        dumpAllPortStatus();
                        break;

                    case 999:
                        pTlStr[0] = '\0';
                        printf ("\nMAC : %2.2x-%2.2x-%2.2x-%2.2x-%2.2x-%2.2x\n",
                                *(char*)0xFFFC0000, *(char*)0xFFFC0001,
                                *(char*)0xFFFC0002, *(char*)0xFFFC0003,
                                *(char*)0xFFFC0004, *(char*)0xFFFC0005);
                        printf ("\nIP : %d.%d.%d.%d\n",
                                *(char*)0xFFFC0006, *(char*)0xFFFC0007,
                                *(char*)0xFFFC0008, *(char*)0xFFFC0009);
                        break;

                    default:
                        printf ("\nInvalid selection: %d", atoi(pTlStr));
                    case 20:
                        pTlStr[0] = '\0';
                        displayMenu = 1;
                        break;
                }
            }

#endif  //NOT ALASKA
            if (strlen(pTlStr)>1)
              ReceiveTLCommand (pTlStr);
#ifdef ALASKA
        if(vdsl_msg.mtype == 2)
          sleep(10);
#else
        }
#endif  //NOT ALASKA
      usleep(100);//manju
    }
}
#endif // BUP_DIAGS

#ifdef INI_SUPPORT
void MacFilterMenu(void)
{
  int MenuSelect;

  int iAddrFilterEn;
  int iLearningEn;
  int iAgingEn;
  int iMultiCastFilterEn;
  int iBroadCastFilterEn;
  int iAgingCount;
  int iStaticEntries;
  U8  abEnetAddr[6];
  U8  retval;
  U8  bBreak = 0;

#ifdef VTU_O
    int dPortNum=0;
    ipos_port_id Pid;
#endif

#if defined(VTU_R) && (defined(P2CPE) || defined(BME_CPE_20))
  // Configure the Ethernet MAC Address filtering settings
  iposPtmfAddrTabInit(&macFilCfgShadow);

  // Read the configuration settings to the passed structure.
  iposPtmfReadAddrTabStatus( &tsEnetAddrFilterConfig);

#endif // defined(VTU_R) && (defined(P2CPE) || defined(BME_CPE_20))
  while (1)
  {
    MacAddr[0] = '\0';
    MenuSelect = 0;
    bBreak = 0;

    printf ("\n ------------------------------------------");
    printf ("\n Ethernet Address Filtering Configuration\n");
    printf ("\n    1) Re-configure                        ");
    printf ("\n    2) Display Address Table               ");
    printf ("\n    3) Edit Static Address Table           ");
    printf ("\n    4) Flush Learned Address Table         ");
    printf ("\n    5) Display Learned Address Table       ");
    printf ("\n   99) EXIT                                ");
    printf ("\n\n Enter Selection: ");

        gets (MacAddr);
    sscanf (MacAddr, "%i", &MenuSelect);

    // Break out of Ethernet Address filtering sub-menu
    if (99 == MenuSelect)
      break;

    else if (5 == MenuSelect)
    {

#if defined(VTU_R) && defined(CPE_30) //&& defined(FIXME)
      U8 i;
      for (i = 0; i < 32; i++)
      {
        U8 abMacAddr[6];
        if (HOST_INI_NO_ERROR == iposPtmfReadLearnedAddr(i, abMacAddr))
        {
          printf ("\n    Address [%02i] = %02x.%02x.%02x.%02x.%02x.%02x",
                i+1,
                abMacAddr[0],
                abMacAddr[1],
                abMacAddr[2],
                abMacAddr[3],
                abMacAddr[4],
                abMacAddr[5]);
        }
        else
        {
          printf ("\n    Address [%02i] = --.--.--.--.--.--",
                i+1);
        }
      }

#elif defined(VTU_O)
      pTlStr[0] = '\0';
      printf (" Enter Port Num.: ");
      gets (MacAddr);
      if (sscanf (MacAddr,"%i",&dPortNum) < 0)
        printf("\n Error: Illegal Port Number");
      else
      {
        getBmePortId(dPortNum, &Pid);
        sprintf( pTlStr, "getrlrndenetaddr::%d:%d;", Pid.bmeNum, Pid.portNum );
        ReceiveTLCommand( pTlStr );
      }
#else
      printf("\n This Feature not supported!!");

#endif
      printf("\n");
      break;
    }

    // Flush the Learned Address table (Only possible on CPE 2.0)
    else if (4 == MenuSelect)
    {

#if defined(VTU_R) && (defined(P2CPE) || defined(BME_CPE_20))

      // FLUSH LEARNED ADDRESS TABLE
      iposPtmfEnetAddrFilterClearTable();

#elif defined(VTU_O)
      pTlStr[0] = '\0';
      printf (" Enter Port Num.: ");
      gets (MacAddr);
      if (sscanf (MacAddr,"%i",&dPortNum) < 0)
        printf("\n Error: Illegal Port Number");
      else
      {
        getBmePortId(dPortNum, &Pid);

          if (oampGetPortState(Pid)==uSHOWTIME)
        {
          printf("\n Flush Learned Addresses for remote port %d\n ", dPortNum);

          // EOC request to Flush the remote CPE's Ethernet Address filtering
          // table
          appEocFlushLearnedAddrReq(Pid);
        }
        else
        {
          printf("\n Port not in SHOW-TIME: EXIT");
        }
      }
#endif // defined(VTU_R) && (defined(P2CPE) || defined(BME_CPE_20))
    }

    // Edit the Static Address Table (i.e. User programmable Addresses)
    else if (3 == MenuSelect)
    {
      // EDIT STATIC ADDRESS TABLE
      int i,j,iMaxTableSize;

#if defined(VTU_O)
      int  iEocTimeout;

      pTlStr[0] = '\0';
      printf (" Enter Port Num.: ");
      gets (MacAddr);

      if (sscanf (MacAddr,"%i",&dPortNum) < 0)
      {
        printf("\n Error: Illegal Port Number");
        bBreak = 1;
      }
      else
      {
        getBmePortId(dPortNum, &Pid);

          if (oampGetPortState(Pid)==uSHOWTIME)
        {
          printf("\n Edit Static Addresses for remote port %d \n", dPortNum);

          AddrFilterEocSema4 = 1;
          iEocTimeout = 10;

          // EOC request to read the remote CPE's Ethernet Address filtering
          // configuration
          appEocCpeReadConfigMacReq(Pid);

          // Wait till response from remote CPE.
          while (AddrFilterEocSema4)
          {
            iposTaskDelay(100);
            iEocTimeout--;
            if (!iEocTimeout)
            {
              printf("\n EOC response timeout: EOC Error/Unknown Command\n");
              tsEnetAddrFilterConfig.bMaxReadCount = 16;
              tsEnetAddrFilterConfig.bStaticAddrCount = 16;

              // If the READ_CONFIG_MAC Command not supported by older version of
              // CPE's then send SHOW_MAC_COMMAND
              AddrFilterEocSema4 = 1;
              iEocTimeout = 10;

              // EOC request to read the remote CPE's Ethernet Address filtering
              // table
              appEocCpeShowMacReq(Pid);

              // Wait till response from remote CPE.
              while (AddrFilterEocSema4)
              {
                iposTaskDelay(100);
                iEocTimeout--;
                if (!iEocTimeout)
                {
                  printf("\n EOC response timeout: EXIT\n");
                  bBreak = 1;
                  AddrFilterEocSema4 =0;
                  break;
                }
              }
            }
          }
        }
        else
        {
          printf("\n Port not in SHOW-TIME");
          bBreak = 1;
        }
      }
#endif //defined(VTU_O)

      j = tsEnetAddrFilterConfig.bMaxReadCount -
          tsEnetAddrFilterConfig.bStaticAddrCount;
      iMaxTableSize = tsEnetAddrFilterConfig.bMaxReadCount;

//      printf ("\nStart = %d; End = %d", j, iMaxTableSize);

      if (!bBreak)
      {
        printf ("\n");
        for (i = j; i < iMaxTableSize; i++)
        {
          printf ("    Address [%02i] = %02x.%02x.%02x.%02x.%02x.%02x : ",
                  i+1,
                  tsEnetAddrFilterConfig.abEnetAddr[i][0],
                  tsEnetAddrFilterConfig.abEnetAddr[i][1],
                  tsEnetAddrFilterConfig.abEnetAddr[i][2],
                  tsEnetAddrFilterConfig.abEnetAddr[i][3],
                  tsEnetAddrFilterConfig.abEnetAddr[i][4],
                  tsEnetAddrFilterConfig.abEnetAddr[i][5]);

          while((retval = EnterSixByteMacAddr(abEnetAddr)))
          {
            if (retval == ' ')
            {
              // RETURN from this sub-menu
              i = iMaxTableSize;
              break;
            }
            if (retval == 0x0d)
            {
              // Leave this entry unchanged.
              break;
            }

            if (retval == 0x18)
            {
              U8  bAddrEnable = 0x1;

  //            printf("\n Delete Entry.......");

              tsEnetAddrFilterConfig.abEnetAddr[i][0] = 0;
              tsEnetAddrFilterConfig.abEnetAddr[i][1] = 0;
              tsEnetAddrFilterConfig.abEnetAddr[i][2] = 0;
              tsEnetAddrFilterConfig.abEnetAddr[i][3] = 0;
              tsEnetAddrFilterConfig.abEnetAddr[i][4] = 0;
              tsEnetAddrFilterConfig.abEnetAddr[i][5] = 0;

              bAddrEnable <<= i;
              tsEnetAddrFilterConfig.uiAddrEntryEn &= ~bAddrEnable;

#if defined(VTU_R) && (defined(P2CPE) || defined(BME_CPE_20))

              iposPtmfRemoveAddrEntry(i);

              macFilCfgShadow = tsEnetAddrFilterConfig;
              nvramUpdateBlk(2);

#elif defined(VTU_O)
              // EOC request to remove the remote CPE's Ethernet Address filtering
              // entry from static table
              appEocCpeRemoveMacReq (Pid,  i);

#endif // defined(VTU_R) && (defined(P2CPE) || defined(BME_CPE_20))

              break;
            }
            // ELSE it is an invalid entry - TRY AGAIN.
            printf("\n Try Again");
            printf ("\n    Address [%02i] = %02x.%02x.%02x.%02x.%02x.%02x : ",
                    i+1,
                    tsEnetAddrFilterConfig.abEnetAddr[i][0],
                    tsEnetAddrFilterConfig.abEnetAddr[i][1],
                    tsEnetAddrFilterConfig.abEnetAddr[i][2],
                    tsEnetAddrFilterConfig.abEnetAddr[i][3],
                    tsEnetAddrFilterConfig.abEnetAddr[i][4],
                    tsEnetAddrFilterConfig.abEnetAddr[i][5]);
          }
          if (retval == 0)
          {
            // VALID ENTRY, Fill the Static table.
            U8  bAddrEnable =0x1;

            tsEnetAddrFilterConfig.abEnetAddr[i][0] = abEnetAddr[0];
            tsEnetAddrFilterConfig.abEnetAddr[i][1] = abEnetAddr[1];
            tsEnetAddrFilterConfig.abEnetAddr[i][2] = abEnetAddr[2];
            tsEnetAddrFilterConfig.abEnetAddr[i][3] = abEnetAddr[3];
            tsEnetAddrFilterConfig.abEnetAddr[i][4] = abEnetAddr[4];
            tsEnetAddrFilterConfig.abEnetAddr[i][5] = abEnetAddr[5];

            bAddrEnable <<= i;
            tsEnetAddrFilterConfig.uiAddrEntryEn |= bAddrEnable;

#if defined(VTU_R) && (defined(P2CPE) || defined(BME_CPE_20))

            iposPtmfAddAddrEntry(i, &tsEnetAddrFilterConfig.abEnetAddr[i][0]);

#elif defined(VTU_O)
            // EOC request to Add the remote CPE's Ethernet Address filtering
            // Entry
            appEocCpeAddMacReq (Pid,  i, &tsEnetAddrFilterConfig.abEnetAddr[i][0]);

#endif // defined(VTU_R) && (defined(P2CPE) || defined(BME_CPE_20))
          }
        }
        printf("\n");

#if defined(VTU_R) && (defined(P2CPE) || defined(BME_CPE_20))

        macFilCfgShadow = tsEnetAddrFilterConfig;
        nvramUpdateBlk(2);

#endif // defined(VTU_R) && (defined(P2CPE) || defined(BME_CPE_20))
      }
    }
    // Display the Ethernet Address Filter Table
    // Just the Static table for CPE 2.0 since the learned table cannot be
    // read or written to.
    // The complete table inclding the learned and user programmable for
    // CPE BME 1.0 using the PTMF FPGA
    else if (2 == MenuSelect)
    {
      // DISPLAY ADDRESS TABLE
      int i, iMaxTableSize;

#if defined(VTU_O)
      int   iEocTimeout;

      pTlStr[0] = '\0';
      printf (" Enter Port Num.: ");
      gets (MacAddr);
      if (sscanf (MacAddr,"%i",&dPortNum) < 0)
      {
        printf("\n Error: Illegal Port Number");
        bBreak = 1;
      }
      else
      {
        getBmePortId(dPortNum, &Pid);

          if (oampGetPortState(Pid)==uSHOWTIME)
        {
          printf("\n Display Static Addresses for remote port %d \n", dPortNum);

          AddrFilterEocSema4 = 1;
          iEocTimeout = 10;

          // EOC request to read the remote CPE's Ethernet Address filtering
          // configuration
          appEocCpeReadConfigMacReq(Pid);

          // Wait till response from remote CPE.
          while (AddrFilterEocSema4)
          {
            iposTaskDelay(100);
            iEocTimeout--;
            if (!iEocTimeout)
            {
              printf("\n EOC response timeout: EOC Error/Unknown Command\n");
              tsEnetAddrFilterConfig.bMaxReadCount = 16;

              // If the READ_CONFIG_MAC Command not supported by older version of
              // CPE's then send SHOW_MAC_COMMAND
              AddrFilterEocSema4 = 1;
              iEocTimeout = 10;

              // EOC request to read the remote CPE's Ethernet Address filtering
              // table
              appEocCpeShowMacReq(Pid);

              // Wait till response from remote CPE.
              while (AddrFilterEocSema4)
              {
                iposTaskDelay(100);
                iEocTimeout--;
                if (!iEocTimeout)
                {
                  printf("\n EOC response timeout: EXIT\n");
                  bBreak = 1;
                  AddrFilterEocSema4 =0;
                  break;
                }
              }
            }
          }
        }
        else
        {
          printf("\n Port not in SHOW-TIME");
          bBreak = 1;
        }
      }

#endif  //#if defined(VTU_O)

      if (!bBreak)
      {
        iMaxTableSize = tsEnetAddrFilterConfig.bMaxReadCount;

        for (i = 0; i < iMaxTableSize; i++)
        {
#if defined(VTU_R) && (defined(P2CPE) || defined(BME_CPE_20))

          iposPtmfReadAddrEntry(i, &tsEnetAddrFilterConfig.abEnetAddr[i][0]);

#endif // defined(VTU_R) && (defined(P2CPE) || defined(BME_CPE_20))

          printf ("\n    Address [%02i] = %02x.%02x.%02x.%02x.%02x.%02x",
                  i+1,
                  tsEnetAddrFilterConfig.abEnetAddr[i][0],
                  tsEnetAddrFilterConfig.abEnetAddr[i][1],
                  tsEnetAddrFilterConfig.abEnetAddr[i][2],
                  tsEnetAddrFilterConfig.abEnetAddr[i][3],
                  tsEnetAddrFilterConfig.abEnetAddr[i][4],
                  tsEnetAddrFilterConfig.abEnetAddr[i][5]);
        }
        printf("\n");
      }
    }
    // Enter sub-menu to edit the Enabling/disabling global filtering,
    // learning, broadcast and multi-cast frames filter.
    else if (1 == MenuSelect)
    {

#if defined(VTU_O)
      int iEocTimeout = 0;

      pTlStr[0] = '\0';
      printf (" Enter Port Num.: ");
      gets (MacAddr);
      if (sscanf (MacAddr,"%i",&dPortNum) < 0)
      {
        printf("\n Error: Illegal Port Number");
        bBreak = 1;
      }
      else
      {
        getBmePortId(dPortNum, &Pid);

          if (oampGetPortState(Pid)==uSHOWTIME)
        {
          printf("\n Re-configure Addr Filter Setings for remote port %d \n", dPortNum);

          AddrFilterEocSema4 = 1;
          iEocTimeout = 10;

          // EOC request to read the remote CPE's Ethernet Address filtering
          // configuration
          appEocCpeReadConfigMacReq(Pid);

          // Wait till response from remote CPE.
          while (AddrFilterEocSema4)
          {
            iposTaskDelay(100);
            iEocTimeout--;
            if (!iEocTimeout)
            {
              printf("\n EOC response timeout: EOC Error/Unknown Command\n");
              tsEnetAddrFilterConfig.bMaxReadCount = 16;
              break;
  //            bBreak = 1;
            }
          }
        }
        else
        {
          printf("\n Port not in SHOW-TIME: EXIT");
          bBreak = 1;
        }
      }

#endif //defined(VTU_O)

      // RE-CONFIGURE ETHERNET ADDRESS FILTER SETTINGS
      // But first read the current settings.
#if defined(VTU_R) && (defined(P2CPE) || defined(BME_CPE_20))

      iposPtmfReadAddrTabStatus( &tsEnetAddrFilterConfig);

#endif // defined(VTU_R) && (defined(P2CPE) || defined(BME_CPE_20))

      if (!bBreak)
      {
        iAddrFilterEn       = tsEnetAddrFilterConfig.bAddrFilterEn;
        iLearningEn         = tsEnetAddrFilterConfig.bLearningEn;
        iAgingEn            = tsEnetAddrFilterConfig.bAgingEn;
        iMultiCastFilterEn  = tsEnetAddrFilterConfig.bMultiCastFilterEn;
        iBroadCastFilterEn  = tsEnetAddrFilterConfig.bBroadCastFilterEn;
        iAgingCount         = tsEnetAddrFilterConfig.uiAgingCount;
        iStaticEntries      = tsEnetAddrFilterConfig.bStaticAddrCount;

        printf ("    Address Filtering.........(0=Disable;1=Enable) [%i]: ",
                  tsEnetAddrFilterConfig.bAddrFilterEn);
        gets(MacAddr);
        sscanf (MacAddr, "%i", &iAddrFilterEn);

        printf ("    Learning..................(0=Disable;1=Enable) [%i]: ",
                  tsEnetAddrFilterConfig.bLearningEn);
        gets(MacAddr);
        sscanf (MacAddr, "%i", &iLearningEn);

#if defined(BME_CPE_20)
        printf ("    Aging.....................(0=Disable;1=Enable) [%i]: ",
                  tsEnetAddrFilterConfig.bAgingEn);
        gets(MacAddr);
        sscanf (MacAddr, "%i", &iAgingEn);
#else
        if (tsEnetAddrFilterConfig.bMaxReadCount == 8)
        {
          printf ("    Aging.....................(0=Disable;1=Enable) [%i]: ",
                    tsEnetAddrFilterConfig.bAgingEn);
          gets(MacAddr);
          sscanf (MacAddr, "%i", &iAgingEn);
        }
#endif //defined(BME_CPE_20)

        printf ("    Multicast Frames Filter...(0=Disable;1=Enable) [%i]: ",
                  tsEnetAddrFilterConfig.bMultiCastFilterEn);
        gets(MacAddr);
        sscanf (MacAddr, "%i", &iMultiCastFilterEn);

        printf ("    Broadcast Frames Filter...(0=Disable;1=Enable) [%i]: ",
                  tsEnetAddrFilterConfig.bBroadCastFilterEn);
        gets(MacAddr);
        sscanf (MacAddr, "%i", &iBroadCastFilterEn);

#if defined(BME_CPE_20)
        printf ("    Aging Count...............(0-65535) [%i]: ",
                  tsEnetAddrFilterConfig.uiAgingCount);
        gets(MacAddr);
        sscanf (MacAddr, "%i", &iAgingCount);

#elif defined(P2CPE)

        printf ("    Host controlled entries...(0-16) [%i]: ",
                  tsEnetAddrFilterConfig.bStaticAddrCount);
        gets(MacAddr);
        sscanf (MacAddr, "%i", &iStaticEntries);
#else
        if (tsEnetAddrFilterConfig.bMaxReadCount == 8)
        {
          printf ("    Aging Count...............(0-65535) [%i]: ",
                    tsEnetAddrFilterConfig.uiAgingCount);
          gets(MacAddr);
          sscanf (MacAddr, "%i", &iAgingCount);
        }
        else
        {
          printf ("    Host controlled entries...(0-16) [%i]: ",
                    tsEnetAddrFilterConfig.bStaticAddrCount);
          gets(MacAddr);
          sscanf (MacAddr, "%i", &iStaticEntries);
        }
#endif //defined(BME_CPE_20)

        tsEnetAddrFilterConfig.bAddrFilterEn      = iAddrFilterEn;
        tsEnetAddrFilterConfig.bLearningEn        = iLearningEn;
        tsEnetAddrFilterConfig.bAgingEn           = iAgingEn;
        tsEnetAddrFilterConfig.bMultiCastFilterEn = iMultiCastFilterEn;
        tsEnetAddrFilterConfig.bBroadCastFilterEn = iBroadCastFilterEn;
        tsEnetAddrFilterConfig.uiAgingCount       = iAgingCount;
        tsEnetAddrFilterConfig.bStaticAddrCount   = iStaticEntries;

        printf("\n");

#if defined(VTU_R) && (defined(P2CPE) || defined(BME_CPE_20))
        iposPtmfAddrTabInit(&tsEnetAddrFilterConfig);

        macFilCfgShadow = tsEnetAddrFilterConfig;
        nvramUpdateBlk(2);

#elif defined(VTU_O)
        if (iEocTimeout)
        {
          // EOC request to configure the remote CPE's Ethernet Address filtering
          // settings // IF appEocCpeReadConfigMacReq has not failed, then
          // remote CPE will accept the extended Config command.
          appEocConfigExtendMacReq (Pid,  &tsEnetAddrFilterConfig);

        }else
        {
          // EOC request to configure the remote CPE's Ethernet Address filtering
          // settings
          appEocConfigMacReq (Pid,  &tsEnetAddrFilterConfig);
        }
#endif // defined(VTU_R) && (defined(P2CPE) || defined(BME_CPE_20))
      }
    }
  }
}
#endif //INI_SUPPORT
/********************************************************************/
U8 EnterSixByteMacAddr(U8 *pbEnetAddr)
{
  unsigned long MAddr;
  char          MacAddrStrg[50];
  char          *NextMacAddr, *CurrMacAddr;
  int           i=0;

  MacAddrStrg[0] = 0x0d;
  gets(MacAddrStrg);
  if (strlen(MacAddrStrg) != 17)
  {
//    printf("%x",MacAddrStrg[0]);

    if (MacAddrStrg[0] == ' ')
      return ' ';

    if (MacAddrStrg[0] == 0)
      return 0x0d;

    if ((MacAddrStrg[0] == '0') && (strlen(MacAddrStrg)== 1))
      return 0x18;

    printf("\nInput Error: String Length");
    return 1;
  }

  CurrMacAddr=NextMacAddr = (char *)&MacAddrStrg;

  do
  {
    MAddr = strtoul(CurrMacAddr, &NextMacAddr, 16);
    if (CurrMacAddr == NextMacAddr)
    {
      printf("\nInput Error: Unknown Character");
      return 1;
    }

    if (i < 5)
    {
      if(*NextMacAddr != '.')
      {
        printf("\nInput Error: Unknown Character (%x)", *NextMacAddr );
        return 1;
      }
    }
    pbEnetAddr[i] = (U8)MAddr;

    NextMacAddr++;
    CurrMacAddr=NextMacAddr;
    i++;
  }while(NextMacAddr < (MacAddrStrg + strlen(MacAddrStrg)));
  return 0;
}

#if defined(USE_RFM) && defined(VTU_O)
static  void    RFMMenu(void)
{
    char    str[256];
    char    TlStr[64];
    int     menuInput = 0, i;
    int     checkDld = 0;
    char    dnld_flag = 0;

    ipos_port_id    pid;


    printf ("\nRemote Firmware Management Menu\n");
    printf ("\n   1) Retrieve the Remote CPE Image Information  ");
    printf ("\n   2) Load CPE Image from a TFTP server  ");
    printf ("\n   3) Download the CPE Image to a Remote CPE ");
    printf ("\n   4) Activate the Remote CPE Image ");
    printf ("\n  99) Exit from menu");
    printf ("\n\nEnter input: ");
    gets (str);
    sscanf (str,"%i",&menuInput);
    switch (menuInput)
    {

        case    1:

            if (getPortNum(&pid) > 0)
            {
                if(oampGetPortState(pid) == uSHOWTIME)
                    sprintf (TlStr,"getcpever:0:%i:%i;",pid.bmeNum,pid.portNum);
                else
                {
                    printf("\nPort %d is not in showtime.", pid.portNum);
                    TlStr[0] = '\0';
                }
            }
            break;

        case    2:

            for (checkDld = 0; checkDld < MAX_NUM_OF_PORTS; checkDld++)
            {
                if(feDldStatus[checkDld])
                {
                    printf("\nError!!! Remote Downloading in Progress\n");
                    dnld_flag = 1;
                    break;
                }
            }

             if (dnld_flag) {
                    dnld_flag = 0;
                    break;
             } else {
            printf("\nEnter the File Name and Host IP Address:");
            printf("\n  (fileName:IP_Address)\n");
            gets(str);

            sprintf(TlStr,"ldimage:0:%s;",str);
             }

            break;

        case    3:
            if (getPortNum(&pid) > 0)
            {
                if (remDldImgFlag)
                {
                    printf("\nError!!! Loading Image from TFTP Server\n");
                    break;
                }
                sprintf (TlStr,"dnldcpe:0:%i:%i;",pid.bmeNum,pid.portNum);
            }
            break;

        case    4:
            if (getPortNum(&pid) > 0)
            {
                printf("\nEnter Activation Option: (0=Immediate, 1=Delayed)");
                gets(str);
                sscanf (str,"%i",&i);
                sprintf (TlStr,"actcpe:0:%i:%i:%i;",pid.bmeNum,pid.portNum, i);
            }

            break;

        case    0:              /* includes no input entered (TT ID 831) */
        case    5:              /* backwards compatibility */
        case    99:             /* TT ID 831 */
            TlStr[0] = '\0';
            break;

        default:
            TlStr[0] = '\0';
            printf("\nInvalid input\n");
            break;
    }   /* switch */


    if (strlen(TlStr))
        ReceiveTLCommand (TlStr);

    pTlStr[0] = '\0';
    return;
}

#endif

#ifdef  BME_CPE_20

static  void    azMemMenu(void)

{
    char    str[256];
    int     menuInput;
#ifndef ALASKA
   // getSysInfo( (char *) &sInfo);
   sInfo.memInfo = 2;

    printf ("\nEnter BME Memory Configuration Selection [%d]: \n", sInfo.memInfo);
    printf ("\n0) SRAM    1) SDRAM 16 bit    2)SDRAM 32 bit \n");

   gets (str); //IXDP425
    if(strlen(str)!=1)
    {
        printf ("\nInvalid selection. The current configuration is [%d].  \n", sInfo.memInfo);
        pTlStr[0] = '\0';
        return;
    }
    sscanf (str,"%i",&menuInput);
    if ((menuInput>=0)&&(menuInput<=2))
    {
        sInfo.memInfo=(char) menuInput;
//        saveSysInfo((char *) &sInfo); //IXDP425
    }

    pTlStr[0] = '\0';
    return;
   return;
#endif
#ifdef ALASKA  // Fusiv
   sInfo.memInfo = 2;
   pTlStr[0] = '\0';
    return;
#endif // Fusiv
}


void PrGpioTestMenu(void)
{
#if defined(CPE20_REF_BOARD)
  int iGpioIn;
#endif //CPE20_REF_BOARD

  int iGpioPin, iGpioPinCfg;
  int MenuSelect;

  while(1)
  {
    MacAddr[0] = '\0';
    MenuSelect = 0;

    printf ("\n -------------------------------------");
    printf ("\n BME-CPE 2.0 GPIO TEST....\n          ");
    printf ("\n    1) Configure Pin                  ");
    printf ("\n    2) Write to GPIO Pin              ");
    printf ("\n    3) Read from GPIO Pin             ");

#if defined(CPE20_REF_BOARD)
    printf ("\n    4) Set Input signal on GPIO Pins  ");
#endif //CPE20_REF_BOARD

    printf ("\n    5) EXIT                           ");
    printf ("\n\n Enter Selection: ");

    gets (MacAddr);
    sscanf (MacAddr, "%i", &MenuSelect);

    // Break out of GPIO PINS TESTs sub-menu
    if (5 == MenuSelect)
      break;

#if defined(CPE20_REF_BOARD)
    else if (4 == MenuSelect)
    {
      pTlStr[0] = '\0';
      printf (" Enter 8 bits GPIO input: ");
      gets (MacAddr);
      sscanf (MacAddr,"%i",&iGpioIn);

      HostFpgaWrite (0x05, iGpioIn & 0xff);
    }
#endif //CPE20_REF_BOARD
    else if (MenuSelect == 1 || MenuSelect == 2 || MenuSelect == 3)
    {
      pTlStr[0] = '\0';
      printf (" Select GPIO Pin(s) (0=All or 1-8): ");
      gets (MacAddr);
      sscanf (MacAddr,"%i", &iGpioPin);

      if (1 == MenuSelect)
      {
        pTlStr[0] = '\0';
        printf (" GPIO Pin Config (0=Input/1=Output): ");
        gets (MacAddr);
        sscanf (MacAddr,"%x", &iGpioPinCfg);

        iposBmeGpioConfig(1, iGpioPin, iGpioPinCfg);
      }

      if (2 == MenuSelect)
      {
        pTlStr[0] = '\0';
        printf (" GPIO Pin Write (0 or 1): ");
        gets (MacAddr);
        sscanf (MacAddr,"%x", &iGpioPinCfg);

        if (iposBmeGpioWrite(1, iGpioPin, iGpioPinCfg))
          printf ("\n Invalid Write ");
      }

      if (3 == MenuSelect)
      {
        pTlStr[0] = '\0';

        if(iGpioPin)
        {
          if (iposBmeGpioRead(1, iGpioPin))
            printf("\n GPIO PIN #%i = ONE", iGpioPin);
          else
            printf("\n GPIO PIN #%i = ZERO", iGpioPin);
        }
        else
          printf("\n GPIO 8 bits = 0x%02lX", iposBmeGpioRead(1, iGpioPin));
      }
    }
    else
      printf("\n Wrong Selection\n");
  }
}

#endif
void brd_cfg(void)
{
    int ife2_mode;

    printf("\n Board Configuration Menu");
    printf("\n  1> Enter IFE II Mode [ 0 = LOW POWER, 1 = HIGH POWER, curr = %d]: ", oampGetIFE2PwrMode);
    scanf("%d",  &ife2_mode);
    oampSetIFE2PwrMode(ife2_mode);
}

#ifdef ALASKA
int getBmePortId_local(ipos_port_id *Pid)
{
        if (getBmePortId(1,Pid) != IPOS_SUCCESS)
        {
          printf("\nPort is not ready or provisioned");
          pTlStr[0] = '\0';
          return -1;
        }
        return 0;
}
void config_VDSL_from_file()
{
   FILE *fp;
   char str[100], *strptr;
   int opt_int;

   fp = fopen("/etc/vdsl.conf","r");
   if(fp==NULL)
   {
        printf("\nconfiguration file /etc/vdsl.conf doesn't exist\n");
        exit(1);
   }
   while(fgets(str,100,fp) != NULL)
   {
        strptr = &str[0];
        //ignore white spaces if any
        while(*strptr == ' ') strptr++;
        if(*strptr == '#' || *strptr == '\n')
          continue;

        opt_int = atoi(strptr);
        switch(opt_int)
        {
          case 3:       //System Provision
            {
              int BandPlan;
              fgets(str,100,fp);

              //Get the BandPlan paramter value
              BandPlan = getParamValue((char *)str);
              oampSetBandPlan(BandPlan);
            }
            break;

          case 21:
            portProvision(fp);
            break;

          case 24:
            opt_int = getParamValue((char *)str);
            if(opt_int==1){
                oampSetUtopiaMode(0x00); } //ATM_MODE
            else if(opt_int == 2){
                oampSetUtopiaMode(0x80); }//PTM Mode
            else
                oampSetUtopiaMode(0xc0);  //EFM Mode
            break;

          case 25:
            sysProvOptionMask(fp);
            break;

          case 31:
          {
            int INIcrc;

            fgets(str,100,fp);
           INIcrc = getParamValue((char *)str);
            if( (INIcrc>0) && (INIcrc<=10000))
            {
              oampSetIniCrcThreshold(INIcrc);
              numCrcCheckFrames = 300000/INIcrc;
            }
            else
            {
              printf("\nIncorrect value entered for INI CRC Threshold\n");
              printf("configure again with correct values\n");
            }
          } //case 31
          break;

          case 56:      //OAMP Options Mask Settings
          {
            int i, mask=0;

            for(i=0;i<3;i++)
            {
              getNextOption(fp, (char *)str);
              opt_int = getParamValue((char *)str);
              switch(i)
              {
                case 1:
                  if(opt_int == 1)
                        mask |= 0x1;
                case 2:
                  if(opt_int == 1)
                        mask |= 0x2;
                case 3:
                  if(opt_int == 0)
                        mask |= 0x80;
              } //switch
            } //for loop
            oampSetOamOptionMask(mask);
          } //case 56
          break;

          case 121:     //Modify auto boot timeout
          {
            int timeout;

            fgets(str,100,fp);
            timeout = getParamValue((char *)str);
            if((timeout >= 0) && (timeout <=100))
            {
              oampSetAutoStartWaitTime(timeout);
            }
            else
            {
              printf("\nIncorrect value entered for AUTO BOOT TIMEOUT\n");
              printf("Leaving the timeout unchaged\n");
            }
          }
          break;

         case 131:
          {
            int vdslCRC;
            ipos_port_id temp;

            fgets(str,100,fp);
            vdslCRC = getParamValue((char *)str);
            if((vdslCRC >= 0) && (vdslCRC <=10000))
            {
              temp.bmeNum  = 0;
              temp.portNum  = 0;
              oampSetVdslCrcThreshold(vdslCRC);
              reCalLineCrcThreshold(temp);
            }
            else
            {
              printf("\nIncorrect value entered for VDSL CRC threshold\n");
              printf("Leaving the VDSL CRC threshold unchanged\n");
            }
          }
          break;

        }  //end of main switch
   } //While loop
   fclose(fp);
}

void portProvision(FILE *fp)
{
   char line[100], *lineptr;
   U8 profileNum = 2;
   U8 PortCmd = PORT_PROVISION;
   int paramValue=0, opt_int, done=0;

   while(fgets(line,100,fp) != NULL)
   {
        lineptr = (char *)line;
        //ignore white spaces if any
        while(*lineptr == ' ') lineptr++;

        if(*lineptr == '#' || *lineptr == '\n')
          continue;

        opt_int = atoi(lineptr);
        if(opt_int <= 4)        //for options 1 to 4
        {
          paramValue = getParamValue((char *)line);
          if( paramValue == -1 ) continue;
        }
        switch(opt_int)
        {
          case 1:
            setPortParameter(profileNum,PortCmd,MIN_NOISE_MARGIN,(U32 *)&paramValue);
            break;
          case 2:
            setPortParameter(profileNum,PortCmd,INTERLEAVED_PERCENTAGE,(U32 *)&paramValue);
            break;

          case 3:
            setPortParameter(profileNum,PortCmd,UPSTREAM_MAX_INTER_DELAY,(U32 *)&paramValue);
            break;

          case 4:
            setPortParameter(profileNum,PortCmd,DOWNSTREAM_MAX_INTER_DELAY,(U32 *)&paramValue);
            break;

          case 5:
          {
            ipos_port_profile *PPP = &sPortProfiles[profileNum];
            U8 rfiBand, rfiBand1, rfiBand2, rfiBand3;

            rfiBand1 = rfiBand2 = rfiBand3 = 0;
            getNextOption(fp, (char *)line);

            for(rfiBand=1; rfiBand<22; rfiBand++) //no.of RFI bands = 22
            {
              lineptr = strchr(line, '[') + 1;
              if(strstr(lineptr,"ON") != NULL)
              {
                switch(rfiBand)
                {
                  case 1:
                  case 2:
                  case 3:
                  case 4:
                  case 5:
                  case 6:
                  case 7:
                  case 8:
                    rfiBand1 |= (U8)(1<<(rfiBand-1));
                    break;

                  case 9:
                  case 10:
                  case 11:
                  case 12:
                  case 13:
                  case 14:
                  case 15:
                  case 16:
                    rfiBand2 |= (U8)(1<<(rfiBand-9));
                    break;

                  case 17:
                  case 18:
                  case 19:
                  case 20:
                  case 21:
                    rfiBand3 |= (U8)(1<<(rfiBand-17));
                    break;

                  default:
                    break;
                } //switch RFIBAND
              } //if

              fgets(line,100,fp);  //get the next RFI band parameter
            }  //for loop -- RFIBAND

            PPP->PortProvParms.RFIBand1 = rfiBand1;
            PPP->PortProvParms.RFIBand2 = rfiBand2;
            PPP->PortProvParms.RFIBand3 = rfiBand3;

          }  //case 5 -- configure RFIBAND
          break;

          case 6:
          {
            U8 portOption = 0;
            int carrierFlag;

            getNextOption(fp, (char *)line);
            for(carrierFlag=0; carrierFlag<4; carrierFlag++)
            {
                lineptr = strchr(line, '[') + 1;
                if(strstr(lineptr,"ON"))
                  portOption = portOption|(1<<carrierFlag);
                fgets(line,100,fp);
            }
            sPortProfiles[2].OptionParms.PortOption = portOption;
          } //end of case 6
          break;

          case 7:
          {
            U8 bandModifier=0;
            int i, band;

            for(i =1; i<4; i++)
            {
              getNextOption(fp, (char *)line);
              switch(i)
              {
                case 1:
                  band = getParamValue((char *)line);
                  bandModifier = (U8)((band&0x3)<<4);
                  break;

                case 2:
                  band = getParamValue((char *)line);
                  bandModifier |= (U8)(band&0xf);
                  break;
                case 3:
                  band = getParamValue((char *)line);
                  bandModifier |= (U8)(band<<6);
                  break;
              }
            } //for loop

            sPortProfiles[2].BandMod.bandModifier = bandModifier;
          } //End of case 7
          break;

          case 8:
          {
            int i, optionValue;

            for(i =1; i<4; i++)
            {
              getNextOption(fp, (char *)line);

              switch(i)
              {
                case 1:
                  optionValue = getParamValue((char *)line);
                  sPortProfiles[2].IFE_BRD_CFG.pwrMode = (U8)optionValue;
                  break;

                case 2:
                  optionValue = getParamValue((char *)line);
                  sPortProfiles[2].IFE_BRD_CFG.rxPathFilterMode = (U8)optionValue;
                  break;

                case 3:
                  optionValue = getParamValue((char *)line);
                  sPortProfiles[2].IFE_BRD_CFG.txPathFilterMode = (U8)optionValue;
                  done =1;
                  break;
              }
            } //for loop
          } //case 8
          break;

          default:
            break;
        }  //main switch
        if(done)
          break; //we are done with system Provision Option Mask. So return
   }  //main while loop
}

int getParamValue(char *line)
{
   //search for the parameter location '['
   line = strchr(line, '[') + 1; //location next to '[' in the line
   if(line == NULL) return -1;

   //remove if any spaces inside the []
   while(*line == ' ') line++;
   return(atoi(line));
}

void getNextOption(FILE *fp, char *line)
{
  while(fgets(line,100,fp) != NULL)
  {
    //ignore white spaces if any
    while(line[0]== ' ') line++;
    //remove comments and empty lines
    if(line[0] == '#' || line[0] == '\n')
      continue;
    break;  //parameter inputs starts here
  }
}

void sysProvOptionMask(FILE *fp)
{
   char line[100], *lineptr;
   int option, done=0;
   float k0[3] = {0.0, 0.0, 0.0};
   float k1[3] = {0.0, 0.0, 0.0};
   float k0_hi[3] = {0.0, 0.0, 0.0};
   float k1_hi[3] = {0.0, 0.0, 0.0};

   while(fgets(line,100,fp) != NULL)
   {
      lineptr = (char *)line;
      while(*lineptr == ' ') lineptr++;
      //remove comments or empty lines
      if(*lineptr == '#' || *lineptr == '\n')
        continue;

      option = atoi(lineptr);
      switch(option)
      {
        case 1:
        {
          int UPBOWeakMode;

          UPBOWeakMode = getParamValue((char *)line);
          if(UPBOWeakMode == 0)
          {
            oampSetOptionMask(oampGetOptionMask&0xdf);
          }
          else
          {
            oampSetOptionMask(oampGetOptionMask|0x20);
          }
          oampSetK_array(k0, k1, k0_hi, k1_hi);
        }
        break;

        case 2:
        {
          int psdMask;

          psdMask = getParamValue((char *)line);
          oampSetPsdLevel(psdMask);
        }
        break;

        case 3:
        {
          int maxPSD, newPsdLevel, i=0;
          tMaxPsd tempMaxPsd = DEFAULT_MAX_PSD;
          char *lineptr;

          maxPSD = getParamValue((char *)line);
          if(maxPSD == 'n')
          {
            break;
          }
          else
          {
            while(i < tempMaxPsd.NumPsd)
            {
                fgets(line,100,fp);
                lineptr = (char *)line;

                while(*lineptr == ' ') lineptr++;
                if(*lineptr == '#' || *lineptr == '\n')
                  continue;

                newPsdLevel = getParamValue((char *)line);
                tempMaxPsd.PsdTone[i].PsdLevel = newPsdLevel;
                tempMaxPsd.PsdTone[i+1].PsdLevel = newPsdLevel;
                i+=2;
            }
            //store the Max PSD structure
            oampSetMaxPsd(&tempMaxPsd);
          }
        }
        break; //case 3

        case 4:
        {
          int ADSLsafeMode;

          ADSLsafeMode = getParamValue((char *)line);
          if(ADSLsafeMode == 0)
          {
            oampSetOptionMask(oampGetOptionMask&(~ADSL_SAFE_MODE));
          }
          else
            oampSetOptionMask(oampGetOptionMask|ADSL_SAFE_MODE);
          done = 1; //we are done with system Provision Option Mask. So return
        }
        break;

      } //switch

      if(done)
        break; //we are done with system Provision Option Mask. So return

   } //outer while loop
} //sysProvOptionMask

#endif  //ALASKA

/* END_OF_FILE */
